<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Arial:300,300italic,400,400italic,700,700italic|Verdana:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="WarmDad的学习与生活记录空间">
<meta property="og:type" content="website">
<meta property="og:title" content="WarmDad&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="WarmDad&#39;s Blog">
<meta property="og:description" content="WarmDad的学习与生活记录空间">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="WarmDad">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>WarmDad's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WarmDad's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/21/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%8E%A7%E5%88%B6%E6%83%85%E7%BB%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%8E%A7%E5%88%B6%E6%83%85%E7%BB%AA/" class="post-title-link" itemprop="url">如何有效控制情绪</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-21 14:45:07 / 修改时间：14:45:57" itemprop="dateCreated datePublished" datetime="2023-07-21T14:45:07+08:00">2023-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>你有没有因为工作的事情而长期处于焦虑状态？</p>
<p>你有没有因为白天被领导批评，晚上回到家里而对家里人乱发脾气？</p>
<p>你有没有因为自己的难以控制的情绪而困扰，纠结于自己难以控制的情绪，然后自己的情绪更加失控了？</p>
<p>这么多的问题让我们越来越关注情绪问题，关注该如何控制情绪，本文先从情绪从哪里来开始，最后提出部分情绪管理的建议，希望能够帮助我们有效的控制情绪。</p>
<h1 id="情绪来自哪里"><a href="#情绪来自哪里" class="headerlink" title="情绪来自哪里"></a>情绪来自哪里</h1><p>从本质上来说，情绪只是一个报警器。当一个刺激发生的时候，我们就会产生某种情绪来应对。想想远古时期，当我们的祖先遇到凶猛的野兽时，如果没有恐惧的情绪，那么他很可能就会因为没有逃跑而成为野兽的食物。</p>
<p>所以，情绪，是从我们的祖先那一直继承而来的，也是进化的产物。这也导致了达尔文错误的认为，人类发展出了理性思维之后情绪便失去了任何建设性的功能，情绪仅仅只是进化的残留物，没有好处，只会造成麻烦。</p>
<p>对于情绪如何解释呢？传统的一个情绪理论就是采用三重脑模型的解释。</p>
<p>三重脑模型是Paul MacLean于上世纪六十年代提出的理论。此理论根据在进化史上出现的先后顺序，将人类大脑分成“<strong>爬行动物脑</strong>”（Reptilian brain）、“<strong>古哺乳动物脑</strong>”（paleomammalian brain）和“<strong>新哺乳动物脑”</strong>（neomammalian brain）三大部分，有时也分别称之为本能脑，情绪脑和理智脑。</p>
<p>这个模型认为，本能脑源于爬行动物，具有脊椎动物的普遍特点，主要维持和调控个体生命的一些重要生理功能。</p>
<p>情绪脑，又称边缘系统。在爬行动物之后，哺乳动物开始登场，为了适应更加复杂的环境，它们慢慢出现了情绪，就像人类一样，小猫和小狗也会因为恐惧而躲避，因为开心而蹦跳。因此，情绪脑主要维持本能和情感行为。</p>
<p>理智脑出现的最晚，它是人类大脑的新皮层，控制着我们的高级认知功能。得益于此，人类学会了理性分析，发展出了灿烂的科技和文化。</p>
<p>虽然本能脑和情绪脑看起来很低级，但是它们掌控着我们的潜意识，并且运行速度极快，而理智脑运行速度很慢，所以就会经常出现一些情绪化而不理智的行为。</p>
<p>但是这个理论也有其不足之处，主要在于：</p>
<ol>
<li>这个模型将三个区域定位为互相独立的，然而大脑各个区域之间其实是存在互动的；</li>
<li>新的科学研究表明，大脑中的情绪产生并非集中在某个特定的区域，而是分布的非常广泛。</li>
</ol>
<p>后来，心理学家詹姆斯·罗素(James Russell)又提出了“核心情绪”理论。所谓核心情绪，它是一种处于基层意识中、先于初级情绪而存在的基础状态，是根据你的身体系统的情况以及对外部信息的看法，读取你的总体幸福感，反映的是你的身体机能。也是一种心理状态，但又比情绪更加原始。简单的说，核心情绪就是身体机能的最原始的反应，一旦核心情绪卷入了价值判断，情绪就产生了。</p>
<p>核心情绪是一种基准状态，在任何时刻，核心情绪都存在，很多时候，是我们没有觉知到当前的核心情绪，但是它却潜在的影响了你的决定，你的思维。</p>
<p>情绪为我们提供了应对各种事件的灵活性，具体作何反应取决于我们过往的经验、期望、知识等，之所以我们会感到情绪，在于我们大脑自发进行的各种复杂心理计算，计算的过程不仅会受到刚刚的直接事件的影响，也会受到诸如核心情绪的其它因素的影响。</p>
<p>掌握核心情绪的要旨就在于对其加以监控，而监测就需要能够正确的认识当下自己的状态，识别出当下自己的情绪。比如工作劳累的一天回到家，看到小孩作业还没写完，然后突然就大发雷霆，为什么，因为你身体的劳累导致了你的核心情绪的消极，如果这时能够意识到自己的疲倦的状态会影响到情绪，就会避免去发火。</p>
<h1 id="情绪有什么作用"><a href="#情绪有什么作用" class="headerlink" title="情绪有什么作用"></a>情绪有什么作用</h1><p>大多人一提到情绪，就会想到焦虑，愤怒，紧张等负面的内容，印象里情绪都是负面的东西，当然，正如上文所说，达尔文也是这么认为的。</p>
<p>为什么我们会有这种偏见呢？</p>
<p>主要在于我们一说起情绪，首先想到的往往都是负面的情绪，生活中的压力，工作上的不稳定，不顺心，让我们在这个现代社会更加容易陷入焦虑，加之网络上和自媒体的各种焦虑贩卖，更加迷失了自我。更加严重的，甚至会陷入抑郁。<br>正是这样，让我们对情绪产生了其只是有害的偏见。</p>
<p>但是通过上述讲的情绪来源，我们知道情绪并非都是负面的。情绪本身是我们进化的产物，它是一个报警器，通过这个报警器告知我们当前是什么情况，应该如何去处理。</p>
<p>比如说，有的人非常敏感。别人的一句话，可能他就会在心里反复纠结那句话的意思，别人的一个不经意的举动，可能就被他认为是侵犯。敏感的人一般精神内耗也很严重。如果领导通知他第二天会和他做个沟通，但是他敏感的内心可能就会不停的上演领导会怎么样，是我最近的工作做的不好吗，到底哪里不好呢，严重的甚至一晚上都睡不着。但是领导仅仅只是想沟通下最近的工作状况而已。</p>
<p>刚刚我们看到敏感给我们造成的困扰，但是敏感真的是一无是处吗？当然不是。我们的大脑就像一个雷达系统，会检测周边的各种信号，敏感的人只是接收了太多的信号，迟钝的人则会漏报很多信号，漏报信号则可能容易遭受“突如其来”的灾难，适当的敏感则能让我们做好准备应对潜在的威胁。</p>
<p>再比如悲伤，它真的都只是负面的吗？其实悲伤也能给我们带来作用，首先，我们悲伤的表情能够引起他人的注意，让他人注意到我们当前正处于悲伤的时刻；其次，悲伤也能促进人的思考，帮助我们适应环境。</p>
<p>情绪还能对我们的思维产生作用，我们来看看量子天才保罗狄拉克的故事。</p>
<p>《量子怪杰：保罗·狄拉克传》中说到保罗狄拉克可以说是一位非常古怪的物理学家，由于他从小长期生活在非常残酷的理性思维的家庭下，几乎没有体验到任何的家庭温暖和爱，所以，即便他智商很高，但是还是早就了他不爱表达，只专注于理性，忽视任何感性的性格。但是后来他遇到了性格非常活泼的曼西，这个曼西简直就是狄拉克的相反面，他们开始了交往，虽然开始的过程也充满的障碍，但最后他们走入的婚姻的殿堂。为什么会这样？用狄拉克写给曼西的信来说就是“你对我来说弥足珍贵。我的生活因你而发生了奇妙的变化，是你让我变成了真正的人。”狄拉克因为曼西发现了自己情绪开始发生了变化，而且他还意识到这种情绪对他的专业思考产生了积极的作用。</p>
<p>所以说，情绪并不都是负面的，相反，如果一个人失去了情绪的帮助，反而会因为无法识别威胁而做出错误的决定。看看那些倾家荡产的赌徒，哪个不是非常乐观的。</p>
<p>其实，最重要的不是出现了负面情绪，而是我们对待负面情绪的态度。</p>
<blockquote>
<p>美国心理学家芭芭拉·弗雷德里克森（Barbara Fredrickson）在对人的情绪做了一定的统计研究后发现，一个正常人每天的正性情绪应该占所有情绪的75%，负性情绪（恐惧、愤怒、厌恶等）占25%。当你出现负性情绪时，要试着理解这种情绪出现的必要性，而不是过度排斥。</p>
</blockquote>
<p>情绪确实有很多作用，能够给我们的决策和生活产生诸多影响，也正因为如此，很多时候，过激的情绪给我们带来了很多困扰，影响了我们的决定，对他人产生了不良的影响等等。所以，做好情绪管理显得就很重要，接下来，就来说说如何做好情绪的管理。</p>
<h1 id="如何做情绪管理"><a href="#如何做情绪管理" class="headerlink" title="如何做情绪管理"></a>如何做情绪管理</h1><p>在做情绪管理之前，我们首先要做的就是得了解自己的情绪。</p>
<p>精神病学家格雷戈里·科恩(Gregory Cohen)提出了“情绪侧写”的概念，他说“每个人都是独一无二的存在，在身体、智力上是如此，在情绪上也是如此。每个人都拥有相同的情绪工具包，但情绪反应的模式却不尽相同，具体情绪表现总会因人而异。这也就是说，虽然大家拥有共同的心理特征，但放到个人身上则会表现出个体差异。”这就是每个人的“情绪侧写”。</p>
<p>简单的说，就是每个人都会有自己的情绪特点，有的人可能更加容易悲伤，有的人更加容易焦虑，有的人更加容易开心，每个人的各种情绪阈值都不相同，这些情绪特点构成了一个人的情绪图谱，这就是一个人的“情绪侧写”。</p>
<p>怎样了解自己的“情绪侧写”呢，简单的方法可以通过一些测试问卷，比如幸福感测试问卷，焦虑感测试问卷，通过这些问卷，我们能够大致了解到自己的情绪现状，只有了解了现状，才能知道如何去做改变。</p>
<p>接下来就介绍几种情绪管理的方法和建议。</p>
<h3 id="1-接受"><a href="#1-接受" class="headerlink" title="1. 接受"></a>1. 接受</h3><p>对于无法改变的事实，焦虑和悲伤都不会给我们带来任何用处，不如好好接纳事实，接受当下的既成事实，着眼于当下和未来可以改变的变量。</p>
<p>著名作家史铁生在双腿残废，不得不坐上轮椅之后，无法接受，恨天恨地，常常情绪失控，但是在他慢慢接受了这个事实之后，平静下来，反而爆发出了新的力量，开始对人生进行了深入的思考，写出了不朽的散文，成为了知名的作家。</p>
<p>接受还有一层含义就是识别出自己当下的情绪，平静的接受它，不苛责自己。</p>
<p>比如明天也会有一个演讲，此时你非常担心自己的表现，非常焦虑，甚至难以入眠。</p>
<p>这个时候，你可以先对自己说，哦，我现在是在焦虑，是在担心，嗯，这些是正常的，要不现在还是好好分析下明天可能会出现哪些情况呢，最坏的又是什么呢？哪些情况都是我能接受的呢？通过这些分析后，你可能就会发现你并不在那么担心，因为即便出现其他状况，也都是你能接受的了，还有什么可怕的呢？</p>
<p>接受的第三层含义就是我们不应期望他人对我们的期望应该是怎样的。我们无法去改变他人，唯一能改变的只是自己。如果你内心的所有欲望都能做到不依赖于自己以外的任何人，那么你就是你自己的主人，这样的自己，还有什么好可怕的呢。这也是希腊斯多葛学派的哲学思想，懂得在自己有能力完成或改变的事情上下功夫，而不要在无能为力的事情上浪费精力，从而掌控自己的人生。</p>
<h3 id="2-重新评估"><a href="#2-重新评估" class="headerlink" title="2. 重新评估"></a>2. 重新评估</h3><p>重新评估就是对刚刚发生的事情，从另一个角度进行解读。</p>
<p>比如接到一个很有挑战性的任务，你可能会这样想“这个我都不会呀，怎么办呀？这次任务要搞砸了。”这样就陷入了焦虑。但是如果换个角度去想，“这对我来说是一次学习新东西的机会，是一次很好的成长机会”，那么，这个时候，可能就不是焦虑了，而是产生了更大的动力去接受这个挑战了。</p>
<p>对于重新评估，美国陆军纳提克士兵系统中心(NSSC)做了一项研究，该研究中的研究对象需要完成3次的90分钟跑步任务，每次跑到30分钟、60分钟以及最终结束的时间点，研究人员都会问他们的劳累程度以及是否感受到疼痛或不快。</p>
<p>第一次跑时，受试者不会受到任何指导，但在接下来的两次跑步中，一半的受试者被要求用重新评估的方法减轻自己的负面情绪，另一半则被要求使用分散注意力的策略，例如想象自己舒服地躺在某个海滩上。最后研究结果发现，转移注意力的方法并不奏效，但采用重新评估的小组则表示，他们感受到的疲惫和痛苦程度明显降低。</p>
<h3 id="3-表达"><a href="#3-表达" class="headerlink" title="3. 表达"></a>3. 表达</h3><p>情绪不好的时候，可以把自己的想法写下来，或者，找一个很好的朋友通过谈话说出来。这也是一种行之有效的情绪管理方法。</p>
<p>甚至学术界为谈论或书写内心感受的行为专门起了个名字，称之为“情绪标注”。</p>
<p>研究表明，情绪标注可以减轻因观看照片和视频而产生的负面情绪，可以平息公开演讲者的紧张焦虑，可以降低创伤后应激障碍的严重程度。</p>
<p>从神经科学角度来说，表达的时候，我们会更多的调动我们的大脑前额皮层的活动，也就理性脑的活动，从而减少情绪脑的活动。</p>
<h3 id="4-阳光"><a href="#4-阳光" class="headerlink" title="4. 阳光"></a>4. 阳光</h3><p>每天工作时可以忙里偷闲，去室外散散步，晒晒太阳，特别是在秋冬季节。</p>
<p>根据澳大利亚Baker Heart and Diabetes研究所的克里斯腾（Kristen Boschwa）的报道，大脑产生血清素的比率与阳光照射的有效时间直接相关。这个想象就是“季节性情绪失调”。</p>
<p>秋冬季节阳光不足，所以往往更加容易产生郁闷和伤感，古代很多诗词都有“悲秋”的说法，或许就跟这有关。</p>
<h3 id="5-社交"><a href="#5-社交" class="headerlink" title="5. 社交"></a>5. 社交</h3><p>上面说到情绪不佳可以与人沟通，这就涉及到了社交的问题。现代人的大多状况是社交不多，更多的人表现出了社恐迹象。其实我自己也是社恐患者。还有一部分人是看起来朋友很多，但是能够真正分享内心想法的几乎没有，这也是社交的问题。</p>
<p>在我看来，真正有效的社交是需要找到几个与自己有着相同价值观的人，可以深入交流，可以彼此分享内心想法的人。即便是社恐患者，一般在一对一交流时也不会存在很多障碍。所谓知我者，二三子，足矣。</p>
<h3 id="6-兴趣"><a href="#6-兴趣" class="headerlink" title="6. 兴趣"></a>6. 兴趣</h3><p>培养一个或几个兴趣爱好作为休息和放松的方式。在情绪不佳的时候，可以做这些自己感兴趣的事情来调节自己的情绪，将这些兴趣作为自己心灵的后花园。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/21/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E8%A3%85%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E8%A3%85%E8%BD%BD/" class="post-title-link" itemprop="url">程序是如何跑起来的-装载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-21 14:43:58 / 修改时间：14:44:22" itemprop="dateCreated datePublished" datetime="2023-07-21T14:43:58+08:00">2023-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>编译链接之后，我们得到了可执行程序，我们知道，可执行程序必须装载到内存种，才能运行。</p>
<h1 id="装载方式"><a href="#装载方式" class="headerlink" title="装载方式"></a>装载方式</h1><p>在一些简单的嵌入式开发中，没有操作系统，整个工程可能就会变成一个程序，然后将程序烧写到某个固定的位置，硬件从这个固定的位置开始执行程序。然后这种方式要求代码和数据必须一次性装入内存，同时，程序所需的内存大小不同超过真实的物理内存大小。如果程序所需内存大小超过了物理内存大小，这种方法就不行了。这就发展出了动态装载的方法。<br>动态装载主要有两种方式：覆盖装入和页映射。</p>
<h2 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h2><p>这也是比较老的方式，现在基本不用了。在本人的开发过程中，一般简单的没有MMU的嵌入式开始都是采用前面说的静态装载的方式，再另一种就是linux下的页映射方式。</p>
<p>简单说说覆盖装入的方式，比如我们程序有三个模块，main，A和B，main会调用A或者B，A和B之间不互相调用。此时，覆盖装入的方式怎么操作呢，首先main模块是一直驻留在内存中，需要调用A时，再将A调入内存<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230614170628.png"></p>
<p>如果需要调用B，此时再将B调入内存，直接覆盖A<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230614170750.png"></p>
<p>当然这个何时装入哪个模块就需要程序员自己去实现一个小的装载管理器了。</p>
<h2 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h2><p>页映射属于虚拟存储机制的一种。这种方式下，程序也是动态载入内存，但是是以页为单位。<br>举个例子，一般情况下页大小为4K，假设我们的程序大小是32K，共8页，内存大小是16K，共4页，显然，程序无法一次载入内存。</p>
<p><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230614173659.png"></p>
<p>当程序开始执行的时候，比如程序入口在P0页，此时发现该页并不在内存中，于是将P0载入物理页面F0，接着运行到P3页，将其载入物理页F1，同样，依次将P5页和P2页载入物理页面F2和F3。如果此时运行到P1页，那么这个物理内存已经满了，此时就需要空出一个页面，用来载入页P1，至于怎么选择，有很多算法可以选择，不在这里讨论之列。后面讨论的linux下的装载方式就是采用这种页映射的方式。在讨论之前，我们先来看看linux下的进程虚拟地址空间。</p>
<h1 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h1><p>我们知道，在虚拟存储的机制下，每个运行的程序都有自己独立的虚拟地址空间。这个虚拟地址空间的大小是由cpu决定，32位的硬件平台对应的虚拟地址就是0x00000000——0xFFFFFFFF，也就是4GB的空间大小；64位平台对应的虚拟地址范围就是0x0000000000000000——0xFFFFFFFFFFFFFFFF，共17179869184GB的空间大小。</p>
<p>实际情况下，ARM64处理器并不支持完全的64位虚拟地址。目前支持情况如下：</p>
<p>虚拟地址的最大宽度是48位，那这48位的寻址空间是用户都能使用吗？并非如此，为了便于管理，linux会把48位的地址空间分成两部分，其中内核空间对应操作系统本身使用的那部分，范围是[0xFFFF000000000000，0xFFFFFFFF FFFF FFFF]，用户虚拟地址则位于64位地址的底部，范围是[0x0000000000000000，0x0000FFFFFFFFFFFF]，中间部分则不允许使用。</p>
<p><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230617161558.png"></p>
<p><font color="#006600">ARMv8架构目前最大支持48位虚拟地址。ARMv8.2 标准支持大虚拟地址，并且页长度是64KB，此时虚拟地址的最大宽度是52位。从 Linux 5.4 内核开始已经支持。</font></p>
<h2 id="虚拟地址空间布局"><a href="#虚拟地址空间布局" class="headerlink" title="虚拟地址空间布局"></a>虚拟地址空间布局</h2><p>对于用户的进程虚拟地址空间，主要包含以下区域：</p>
<ol>
<li>.text段、.data段和.bss段；</li>
<li>动态库的.text段、.data段和.bss段；</li>
<li>存放动态分配的数据的堆；</li>
<li>存放局部变量和实现函数调用的栈；</li>
<li>存在栈底部的环境变量和参数字符串；</li>
<li>把文件区间映射到虚拟地址空间的内存映射区域。</li>
</ol>
<p>对于每个用户进程，都有一个内存描述符mm_struct，用来管理进程的内存区域和对应的页表映射，所以每个进程控制块结构task_struct中都有一个指针mm指向mm_struct这个数据结构。该结构的部分关键信息如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mm_struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> *mmap;        <span class="comment">/* 虚拟内存区域链表 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">rb_root</span> mm_rb;  <span class="comment">/* 虚拟内存区域红黑树 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">		<span class="comment">/* 在内存映射区域找到一个没有映射的区域 */</span></span><br><span class="line">        <span class="function"><span class="type">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> mmap_base;    <span class="comment">/* 内存映射区域的起始地址 */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> task_size;    <span class="comment">/* 用户虚拟地址空间的长度 */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">pgd_t</span> * pgd;  <span class="comment">/* 指向第一级页表 */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">atomic_t</span> mm_users; <span class="comment">/* 共享同一个用户虚拟地址空间的进程的数量 */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">atomic_t</span> mm_count; <span class="comment">/* 内存描述符的引用计数 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> map_count;          <span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code; <span class="comment">/* 代码段的起始地址和结束地址 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> start_data, end_data; <span class="comment">/* 数据段的起始地址和结束地址 */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk; <span class="comment">/* 堆的起始地址和结束地址 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> start_stack;    <span class="comment">/* 栈的起始地址 */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end; <span class="comment">/* 参数字符串的起始地址和结束地址 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> env_start, env_end; <span class="comment">/* 环境变量的起始地址和结束地址 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">linux_binfmt</span> *binfmt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">    &#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * The mm_cpumask needs to be at the end of mm_struct, because it</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * is dynamically sized based on nr_cpu_ids.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_bitmap[];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的一个简单的关系图如下所示</p>
<p><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230620084730.png"></p>
<h1 id="linux下装载过程"><a href="#linux下装载过程" class="headerlink" title="linux下装载过程"></a>linux下装载过程</h1><p>在linux下，比如我们得到一个hello的可执行程序，那么在shell中通过执行./hello便可运行这个程序。</p>
<p>那么在这背后，都发生了什么呢？我们说一个运行的程序就是一个进程，每个进程都有自己的内存空间， 这又是怎么回事呢？这就是接下来的主要内容。</p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>在shell中执行./hello时，其实shell就会创建一个新的进程，然后在新的进程中装载hello程序。其简要代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ret = fork();</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//父进程继续执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">	ret = execve(<span class="string">&quot;hello&quot;</span>, argv, envp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//创建子进程失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先用fork系统调用创建一个新的进程，然后调用而下execve将执行的elf文件加载起来，然后调到程序文件的运行入口，就可以运行这个程序了。</p>
<p>简要讲一下fork系统调用，fork从一个已经存在的进程复制出一个新的进程，所以，创建出的子进程是父进程的一个副本，采用了写时复制的技术。所以这个系统调用在内核的实现关键在于copy_process函数。</p>
<p>copy_process通过dup_task_struct创建一个新的task_struct节点，并用当前进程的相关信息初始化这个新建的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> pid *pid,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                    <span class="type">int</span> trace,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                    <span class="type">int</span> node,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> kernel_clone_args *args)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pidfd = <span class="number">-1</span>, retval;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    p = dup_task_struct(current, node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy all the process information */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_semundo(clone_flags, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_files(clone_flags, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_fs(clone_flags, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_sighand(clone_flags, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_signal(clone_flags, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_mm(clone_flags, p);</span><br><span class="line"></span><br><span class="line">    retval = copy_namespaces(clone_flags, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_io(clone_flags, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    retval = copy_thread(clone_flags, args-&gt;<span class="built_in">stack</span>, args-&gt;stack_size, p, args-&gt;tls);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装载程序"><a href="#装载程序" class="headerlink" title="装载程序"></a>装载程序</h2><p>进程创建之后，通过系统调用execve来装载可执行文件并运行程序。execve在内核的实现主要通过函数do_execveat_common实现，这里面一个重要功能就是读取并解析elf文件，建立虚拟空间与可执行文件的映射关系。</p>
<h2 id="do-execveat-common"><a href="#do-execveat-common" class="headerlink" title="do_execveat_common"></a>do_execveat_common</h2><p>在内核的调用关系如下：<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230627204253.png"></p>
<p>内核支持多种二进制格式文件，对于每种文件都提供了一组统一的操作函数，其中load_binary的功能就是加载程序。<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230626202740.png"></p>
<p>简单分析下do_execveat_common这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_execveat_common</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> filename *filename,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> user_arg_ptr argv,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> user_arg_ptr envp,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                  <span class="type">int</span> flags)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> *<span class="title">bprm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">	</span><br><span class="line">    bprm = alloc_bprm(fd, filename);  <span class="comment">//分配linux_binprm结构</span></span><br><span class="line"></span><br><span class="line">    retval = count(argv, MAX_ARG_STRINGS); <span class="comment">//获取参数个数</span></span><br><span class="line"></span><br><span class="line">    bprm-&gt;argc = retval;</span><br><span class="line"></span><br><span class="line">    retval = count(envp, MAX_ARG_STRINGS);  <span class="comment">//获取环境变量个数</span></span><br><span class="line"></span><br><span class="line">    bprm-&gt;envc = retval;</span><br><span class="line"></span><br><span class="line">    retval = bprm_stack_limits(bprm);   <span class="comment">// 设置执行堆栈的限制</span></span><br><span class="line"></span><br><span class="line">    retval = copy_string_kernel(bprm-&gt;filename, bprm); <span class="comment">//复制文件名</span></span><br><span class="line"></span><br><span class="line">    bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line">    retval = copy_strings(bprm-&gt;envc, envp, bprm); <span class="comment">//复制环境变量</span></span><br><span class="line"></span><br><span class="line">    retval = copy_strings(bprm-&gt;argc, argv, bprm); <span class="comment">//复制命令行参数</span></span><br><span class="line"></span><br><span class="line">    retval = bprm_execve(bprm, fd, filename, flags); <span class="comment">//执行可执行文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数开始首先会分配一个linux_binprm结构，然后对这个结构做一些初始化的工作，最后调用bprm_execve执行可执行文件。<br><code>struct linux_binprm</code>是一个用于表示正在执行的可执行文件（二进制文件）的结构体，它包含了一些成员变量来存储和管理与该文件执行相关的信息。<br>进一步查看alloc_bprm这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> linux_binprm *<span class="title function_">alloc_bprm</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> filename *filename)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> *<span class="title">bprm</span> =</span> kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == AT_FDCWD || filename-&gt;name[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        bprm-&gt;filename = filename-&gt;name;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filename-&gt;name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            bprm-&gt;fdpath = kasprintf(GFP_KERNEL, <span class="string">&quot;/dev/fd/%d&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">            bprm-&gt;fdpath = kasprintf(GFP_KERNEL, <span class="string">&quot;/dev/fd/%d/%s&quot;</span>,</span><br><span class="line"></span><br><span class="line">                          fd, filename-&gt;name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bprm-&gt;fdpath)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        bprm-&gt;filename = bprm-&gt;fdpath;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bprm-&gt;interp = bprm-&gt;filename;</span><br><span class="line"></span><br><span class="line">    retval = bprm_mm_init(bprm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bprm;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bprm_mm_init</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    bprm-&gt;mm = mm = mm_alloc();</span><br><span class="line"></span><br><span class="line">    task_lock(current-&gt;group_leader);</span><br><span class="line"></span><br><span class="line">    bprm-&gt;rlim_stack = current-&gt;signal-&gt;rlim[RLIMIT_STACK];</span><br><span class="line"></span><br><span class="line">    task_unlock(current-&gt;group_leader);</span><br><span class="line"></span><br><span class="line">    err = __bprm_mm_init(bprm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __bprm_mm_init(<span class="keyword">struct</span> linux_binprm *bprm)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> bprm-&gt;mm;</span><br><span class="line"></span><br><span class="line">    bprm-&gt;vma = vma = vm_area_alloc(mm);</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_end = STACK_TOP_MAX;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_start = vma-&gt;vm_end - PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(vma-&gt;vm_flags);</span><br><span class="line"></span><br><span class="line">    err = insert_vm_struct(mm, vma);</span><br><span class="line"></span><br><span class="line">    mm-&gt;stack_vm = mm-&gt;total_vm = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    bprm-&gt;p = vma-&gt;vm_end - <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在alloc_bprm中，申请了linux_binprm结构后做了部分初始化，然后调用bprm_mm_init，申请地址空间对象mm，给新的进程使用。<br>重点看下__bprm_mm_init这个函数，这里面申请了一个VMA空间，这个空间的结束位置位于栈顶的地方，大小为一个页的大小，也就4KB，也就是默认申请了一个页大小的栈空间，最后将<code>vma-&gt;vm_end - sizeof(void *)</code>的值赋给<code>bprm-&gt;p</code>，bprm-&gt;p指向在<br>栈底保留一个字长（指针长度）后的位置。<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230628150517.png"></p>
<p>紧接着，开始拷贝环境变量和命令行参数。我们知道，一个进程中的环境变量和命令行参数是存在栈中的，所以，在这之前，需要申请好栈。看下copy_strings这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_strings</span><span class="params">(<span class="type">int</span> argc, <span class="keyword">struct</span> user_arg_ptr argv,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">kmapped_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kaddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> kpos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (argc-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> __user *str;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> pos;</span><br><span class="line"></span><br><span class="line">        ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">        str = get_user_arg_ptr(argv, argc);</span><br><span class="line"></span><br><span class="line">        len = strnlen_user(str, MAX_ARG_STRLEN);</span><br><span class="line"></span><br><span class="line">        pos = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line">        str += len;</span><br><span class="line"></span><br><span class="line">        bprm-&gt;p -= len;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> offset, bytes_to_copy;</span><br><span class="line"></span><br><span class="line">            offset = pos % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                offset = PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            bytes_to_copy = offset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            offset -= bytes_to_copy;</span><br><span class="line"></span><br><span class="line">            pos -= bytes_to_copy;</span><br><span class="line"></span><br><span class="line">            str -= bytes_to_copy;</span><br><span class="line"></span><br><span class="line">            len -= bytes_to_copy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!kmapped_page || kpos != (pos &amp; PAGE_MASK)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">                page = get_arg_page(bprm, pos, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"></span><br><span class="line">                    ret = -E2BIG;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (kmapped_page) &#123;</span><br><span class="line"></span><br><span class="line">                    flush_kernel_dcache_page(kmapped_page);</span><br><span class="line"></span><br><span class="line">                    kunmap(kmapped_page);</span><br><span class="line"></span><br><span class="line">                    put_arg_page(kmapped_page);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                kmapped_page = page;</span><br><span class="line"></span><br><span class="line">                kaddr = kmap(kmapped_page);</span><br><span class="line"></span><br><span class="line">                kpos = pos &amp; PAGE_MASK;</span><br><span class="line"></span><br><span class="line">                flush_arg_page(bprm, kpos, kmapped_page);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(kaddr+offset, str, bytes_to_copy)) &#123;</span><br><span class="line"></span><br><span class="line">                ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的核心就是将参数拷贝到栈中。</p>
<p>在bprm_execve中，首先调用do_open_execat打开可执行文件，然后调用sched_exec实现处理器负载均衡，然后在search_binary_handler函数中，还会执行prepare_binprm函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">prepare_binprm</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(bprm-&gt;buf, <span class="number">0</span>, BINPRM_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kernel_read(bprm-&gt;file, bprm-&gt;buf, BINPRM_BUF_SIZE, &amp;pos);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数读取文件头部的128字节到linux_binprm结构的buf中。</p>
<p>总结从do_execveat_common这个函数到load_binary之前主要做了以下几件事：</p>
<ol>
<li>申请linux_binprm对象并初始化；</li>
<li>申请mm_struct对象供新的进程使用；</li>
<li>给新的进程栈申请一页的空间；</li>
<li>读取二进制文件的头128字节。</li>
</ol>
<p>接下来，再来分析load_elf_binary这个函数，不过在分析这个函数之前，我们先来看下链接视图和执行视图的问题。</p>
<h2 id="链接视图和执行视图"><a href="#链接视图和执行视图" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h2><p>可执行文件在装载过程中，每一个段，都会映射到进程地址空间中的一个段。这种映射关系只是保存在内核内部的一个数据结构，也就是vm_area_struct，Linux中将进程虚拟地址空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。也就是说，可执行文件中的每一个段都会对应一个VMA。比如.text段，就会在进程虚拟地址空间中有个对应的VMA。</p>
<p>但是，很快我们就会发现一个问题，那就是一个可执行文件中会有很多的段，同时，段映射到进程地址空间的时候是按照页长度为单位的，也就是说在进程虚拟地址空间中，每个段的长度都是页长度的整数倍，比如页长度是4K，那么即便这个段的大小只有4097bytes，也会占用两个页面。很明显，这会造成很大的空间浪费。</p>
<p>那么，如何减少这种浪费呢？其实在装载的过程中，系统并不太关心各个段的内容，更加关心的是各个段的权限问题（可读，可写，可执行）。这样，就可以针对各个段根据权限进行分组，大致分三组：</p>
<ol>
<li>可读可执行，比如代码段；</li>
<li>可读可写，比如数据段和bss段；</li>
<li>只读，比如只读数据</li>
</ol>
<p>为此，ELF可执行文件引入了一个概念“Segment”，一个Segment包含一个或多个属性类似的Section。比如，可以把.text段和.init段合并看成一个Segment，装载的时候就可以将它们作为一个整体进行映射，这样映射后在进程虚拟地址空间中只有一个VMA，而不是两个，减少了内存碎片。<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230629150007.png"></p>
<p>所以，链接器在将目标文件链接成可执行文件的时候，会尽量把相同属性的段分配在同一空间。系统正是按照Segment而不是Section来执行可执行文件的。</p>
<p>来看一个简单的例子，还是以前的Segment.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_blobal_val_init = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> g_blobal_val_uninit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_uninit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_init = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    func(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用静态链接的方式编译成可执行文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -<span class="type">static</span> SegmentTest.c -o SegmentTest.elf</span><br></pre></td></tr></table></figure>

<p>采用readelf工具查看，这个可执行文件有35个段（Section）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -S SegmentTest.elf </span><br><span class="line">There are 35 section headers, starting at offset 0x382bc8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.ABI-tag     NOTE             0000000000400190  00000190</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .rela.plt         RELA             00000000004001b0  000001b0</span><br><span class="line">       00000000000000a8  0000000000000018  AI       0    20     8</span><br><span class="line">  [ 3] .init             PROGBITS         0000000000400258  00000258</span><br><span class="line">       0000000000000018  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 4] .plt              PROGBITS         0000000000400270  00000270</span><br><span class="line">       0000000000000070  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 5] .text             PROGBITS         0000000000400300  00000300</span><br><span class="line">       000000000004f7a8  0000000000000000  AX       0     0     64</span><br><span class="line">  [ 6] __libc_freeres_fn PROGBITS         000000000044fab0  0004fab0</span><br><span class="line">       0000000000000b8c  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 7] .fini             PROGBITS         000000000045063c  0005063c</span><br><span class="line">       0000000000000014  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 8] .rodata           PROGBITS         0000000000450650  00050650</span><br><span class="line">       000000000001c438  0000000000000000   A       0     0     16</span><br><span class="line">  [ 9] __libc_subfreeres PROGBITS         000000000046ca88  0006ca88</span><br><span class="line">       0000000000000048  0000000000000000   A       0     0     8</span><br><span class="line">  [10] __libc_IO_vtables PROGBITS         000000000046cad0  0006cad0</span><br><span class="line">       0000000000000690  0000000000000000   A       0     0     8</span><br><span class="line">  [11] __libc_atexit     PROGBITS         000000000046d160  0006d160</span><br><span class="line">       0000000000000008  0000000000000000   A       0     0     8</span><br><span class="line">  [12] .eh_frame         PROGBITS         000000000046d168  0006d168</span><br><span class="line">       000000000000ad64  0000000000000000   A       0     0     8</span><br><span class="line">  [13] .gcc_except_table PROGBITS         0000000000477ecc  00077ecc</span><br><span class="line">       000000000000009e  0000000000000000   A       0     0     1</span><br><span class="line">  [14] .tdata            PROGBITS         00000000004883a0  000783a0</span><br><span class="line">       0000000000000020  0000000000000000 WAT       0     0     8</span><br><span class="line">  [15] .tbss             NOBITS           00000000004883c0  000783c0</span><br><span class="line">       0000000000000040  0000000000000000 WAT       0     0     8</span><br><span class="line">  [16] .init_array       INIT_ARRAY       00000000004883c0  000783c0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [17] .fini_array       FINI_ARRAY       00000000004883d0  000783d0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [18] .data.rel.ro      PROGBITS         00000000004883e0  000783e0</span><br><span class="line">       0000000000000b64  0000000000000000  WA       0     0     8</span><br><span class="line">  [19] .got              PROGBITS         0000000000488f48  00078f48</span><br><span class="line">       00000000000000a0  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .got.plt          PROGBITS         0000000000488fe8  00078fe8</span><br><span class="line">       0000000000000050  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .data             PROGBITS         0000000000489038  00079038</span><br><span class="line">       0000000000001958  0000000000000000  WA       0     0     8</span><br><span class="line">  [22] .bss              NOBITS           000000000048a990  0007a990</span><br><span class="line">       00000000000015f8  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] __libc_freer[...] NOBITS           000000000048bf88  0007a990</span><br><span class="line">       0000000000000020  0000000000000000  WA       0     0     8</span><br><span class="line">  [24] .comment          PROGBITS         0000000000000000  0007a990</span><br><span class="line">       000000000000005d  0000000000000001  MS       0     0     1</span><br><span class="line">  [25] .debug_aranges    PROGBITS         0000000000000000  0007a9f0</span><br><span class="line">       0000000000003c30  0000000000000000           0     0     16</span><br><span class="line">  [26] .debug_info       PROGBITS         0000000000000000  0007e620</span><br><span class="line">       00000000001171b1  0000000000000000           0     0     1</span><br><span class="line">  [27] .debug_abbrev     PROGBITS         0000000000000000  001957d1</span><br><span class="line">       0000000000028ed7  0000000000000000           0     0     1</span><br><span class="line">  [28] .debug_line       PROGBITS         0000000000000000  001be6a8</span><br><span class="line">       000000000006a3de  0000000000000000           0     0     1</span><br><span class="line">  [29] .debug_str        PROGBITS         0000000000000000  00228a86</span><br><span class="line">       00000000000132f6  0000000000000001  MS       0     0     1</span><br><span class="line">  [30] .debug_loc        PROGBITS         0000000000000000  0023bd7c</span><br><span class="line">       0000000000108d09  0000000000000000           0     0     1</span><br><span class="line">  [31] .debug_ranges     PROGBITS         0000000000000000  00344a90</span><br><span class="line">       00000000000272e0  0000000000000000           0     0     16</span><br><span class="line">  [32] .symtab           SYMTAB           0000000000000000  0036bd70</span><br><span class="line">       0000000000010a40  0000000000000018          33   1779     8</span><br><span class="line">  [33] .strtab           STRTAB           0000000000000000  0037c7b0</span><br><span class="line">       00000000000062a5  0000000000000000           0     0     1</span><br><span class="line">  [34] .shstrtab         STRTAB           0000000000000000  00382a55</span><br><span class="line">       000000000000016e  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再来看elf的Segment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -l SegmentTest.elf </span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x400540</span><br><span class="line">There are 6 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000077f6a 0x0000000000077f6a  R E    0x10000</span><br><span class="line">  LOAD           0x00000000000783a0 0x00000000004883a0 0x00000000004883a0</span><br><span class="line">                 0x00000000000025f0 0x0000000000003c08  RW     0x10000</span><br><span class="line">  NOTE           0x0000000000000190 0x0000000000400190 0x0000000000400190</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x4</span><br><span class="line">  TLS            0x00000000000783a0 0x00000000004883a0 0x00000000004883a0</span><br><span class="line">                 0x0000000000000020 0x0000000000000060  R      0x8</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x00000000000783a0 0x00000000004883a0 0x00000000004883a0</span><br><span class="line">                 0x0000000000000c60 0x0000000000000c60  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.ABI-tag .rela.plt .init .plt .text __libc_freeres_fn .fini .rodata __libc_subfreeres __libc_IO_vtables __libc_atexit .eh_frame .gcc_except_table </span><br><span class="line">   01     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs </span><br><span class="line">   02     .note.ABI-tag </span><br><span class="line">   03     .tdata .tbss </span><br><span class="line">   04     </span><br><span class="line">   05     .tdata .init_array .fini_array .data.rel.ro .got </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只有6个Segment，装载时，基本只关心”LOAD”属性的两个Segment，其它“NOTE”，“TLS”，“GNU_STACK”都是起辅助作用的。</p>
<p>所以，Segment和Section是从不同的角度来看同一个ELF文件，从Section的角度来看ELF文件就是<strong>链接视图</strong>，从Segment的角度来看就是<strong>执行视图</strong>。装载时，我们说的段，专门指Segment，而其他情况下，段则是指Section。</p>
<h2 id="load-elf-binary"><a href="#load-elf-binary" class="headerlink" title="load_elf_binary"></a>load_elf_binary</h2><p>load_elf_binary总的流程如下图：</p>
<h2 id="检查elf首部"><a href="#检查elf首部" class="headerlink" title="检查elf首部"></a>检查elf首部</h2><p>之前在[[程序是如何跑起来的-目标文件]]中，简单分析了elf的首部结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_type;  <span class="comment">/*elf 文件类型，1表示可重定位文件（目标文件），2表示可  </span></span><br><span class="line"><span class="comment">执行文件，3表示动态库，4表示核心转储文件*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_machine; <span class="comment">/* 机器类别，例如EM_ARM(40)表示ARM 32位，  </span></span><br><span class="line"><span class="comment">EM_AARCH64(183)表示ARM 64位*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_version;  <span class="comment">/*版本，用来区分不同的ELF变体*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr e_entry;   <span class="comment">/* 程序入口的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_phoff;    <span class="comment">/* 程序首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_shoff;    <span class="comment">/* 节首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_flags;   <span class="comment">/* 处理器特定的标志 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_ehsize;  <span class="comment">/* ELF首部的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phentsize; <span class="comment">/* 程序首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phnum;     <span class="comment">/* 程序首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shentsize;  <span class="comment">/* 节首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shnum;     <span class="comment">/* 节首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shstrndx;   <span class="comment">/* 节名称字符串表在节首部表中的索引 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf_ex</span> =</span> (<span class="keyword">struct</span> elfhdr *)bprm-&gt;buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elf_ex-&gt;e_type != ET_EXEC &amp;&amp; elf_ex-&gt;e_type != ET_DYN)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!elf_check_arch(elf_ex))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elf_check_fdpic(elf_ex))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bprm-&gt;file-&gt;f_op-&gt;mmap)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>利用之前读取的首部128字节信息，判断elf首部的相关信息，包括magic数字，arch等。</p>
<h2 id="load-elf-phdrs"><a href="#load-elf-phdrs" class="headerlink" title="load_elf_phdrs"></a>load_elf_phdrs</h2><p>这个函数的功能是读取程序首部表（Program Header Table），程序首部表也是一个结构体数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_type;</span><br><span class="line"></span><br><span class="line">  Elf64_Word p_flags;</span><br><span class="line"></span><br><span class="line">  Elf64_Off p_offset;   <span class="comment">/* Segment 在文件中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_vaddr;   <span class="comment">/* Segment 的进程虚拟地址空间 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_paddr;   <span class="comment">/* Segment 物理加载地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_filesz;   <span class="comment">/* Segment 在elf文件中的占用空间长度，可能为0 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_memsz;    <span class="comment">/* Segment 在进程虚拟地址空间中的长度，可能为0 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_align;    <span class="comment">/* Segment 对齐属性 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> elf_phdr *<span class="title function_">load_elf_phdrs</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> elfhdr *elf_ex,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> file *elf_file)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_phdr</span> *<span class="title">elf_phdata</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> retval, err = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_phdr) * elf_ex-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">    elf_phdata = kmalloc(size, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    retval = elf_read(elf_file, elf_phdata, size, elf_ex-&gt;e_phoff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elf_phdata;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就是从程序首部表的位置读取所有的程序首部表信息到一个数组中。</p>
<p><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230628202557.png"></p>
<p>在读取程序首部表之后，会在程序首部表中查找解释器段，这跟动态链接库有关，这里不展开。<br>函数begin_new_exec则终止线程组中的所有其他线程，释放旧的用户虚拟地址空间。函数setup_new_exec调用函数arch_pick_mmap_layout以设置内存映射的布局，然后调用函数set_arg_pages把用户栈定下来，并扩大用户栈，然后开始加载Segment。</p>
<h2 id="Segment加载"><a href="#Segment加载" class="headerlink" title="Segment加载"></a>Segment加载</h2><p>执行Segment加载的主要代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">elf_bss = <span class="number">0</span>;</span><br><span class="line">elf_brk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">start_code = ~<span class="number">0UL</span>;</span><br><span class="line">end_code = <span class="number">0</span>;</span><br><span class="line">start_data = <span class="number">0</span>;</span><br><span class="line">end_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, elf_ppnt = elf_phdata;</span><br><span class="line">	i &lt; elf_ex-&gt;e_phnum; i++, elf_ppnt++) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> elf_prot, elf_flags;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> k, vaddr;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> alignment;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (elf_ppnt-&gt;p_type != PT_LOAD)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	elf_prot = make_prot(elf_ppnt-&gt;p_flags, &amp;arch_state,</span><br><span class="line"></span><br><span class="line">				 !!interpreter, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	vaddr = elf_ppnt-&gt;p_vaddr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,</span><br><span class="line"></span><br><span class="line">			elf_prot, elf_flags, total_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!load_addr_set) &#123;</span><br><span class="line"></span><br><span class="line">		load_addr_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		load_addr = (elf_ppnt-&gt;p_vaddr - elf_ppnt-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k = elf_ppnt-&gt;p_vaddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((elf_ppnt-&gt;p_flags &amp; PF_X) &amp;&amp; k &lt; start_code)</span><br><span class="line"></span><br><span class="line">		start_code = k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start_data &lt; k)</span><br><span class="line"></span><br><span class="line">		start_data = k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	k = elf_ppnt-&gt;p_vaddr + elf_ppnt-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (k &gt; elf_bss)</span><br><span class="line">		elf_bss = k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((elf_ppnt-&gt;p_flags &amp; PF_X) &amp;&amp; end_code &lt; k)</span><br><span class="line">		end_code = k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_data &lt; k)</span><br><span class="line">		end_data = k;</span><br><span class="line"></span><br><span class="line">	k = elf_ppnt-&gt;p_vaddr + elf_ppnt-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (k &gt; elf_brk) &#123;</span><br><span class="line">		bss_prot = elf_prot;</span><br><span class="line">		elf_brk = k;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e_entry = elf_ex-&gt;e_entry + load_bias;</span><br><span class="line">elf_bss += load_bias;</span><br><span class="line">elf_brk += load_bias;</span><br><span class="line">start_code += load_bias;</span><br><span class="line">end_code += load_bias;</span><br><span class="line">start_data += load_bias;</span><br><span class="line">end_data += load_bias;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mm = current-&gt;mm;</span><br><span class="line">mm-&gt;end_code = end_code;</span><br><span class="line">mm-&gt;start_code = start_code;</span><br><span class="line">mm-&gt;start_data = start_data;</span><br><span class="line">mm-&gt;end_data = end_data;</span><br><span class="line">mm-&gt;start_stack = bprm-&gt;p;</span><br></pre></td></tr></table></figure>

<p>遍历所有Segment，对具有LOAD属性的Segment进行加载，elf_map函数的作用是在虚拟地址空间中为其分配虚拟内存。最后对结构体mm的start_code,end_code,start_data,end_data进行赋值。<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230717201512.png"></p>
<h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>堆和栈在进程虚拟地址空间中也以VMA的形式存在，通常，一个进程中的堆和栈分别都有一个对应的VMA。在linux下，通过查看”/proc”可以查看进程的虚拟空间分布，修改一下之前的SegmentTest程序，让它一直运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_blobal_val_init = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> g_blobal_val_uninit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_uninit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_init = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        func(a, b);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后查看proc<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/20230718165300.png"></p>
<p>可以看出，这个进程有8个VMA。结果中，第一列是VMA的地址范围，第二列是VMA的权限，第三列是偏移，第四列是映像文件所在设备的主设备号和次设备号，第五列表示映像文件的节点号，最后一列是映像文件的路径。<br>主设备号和次设备号都是0表示它们没有映射到文件中，这种VMA叫做匿名虚拟内存区域。可以看到，8个VMA中只有前三个映射到可执行文件中的Segment，没有映射到文件中的就有堆（heap）和栈（stack）。</p>
<p>再来看装载过程中堆的处理代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">retval = set_brk(elf_bss, elf_brk, bss_prot);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">set_brk</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> end, <span class="type">int</span> prot)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    start = ELF_PAGEALIGN(start);</span><br><span class="line">    end = ELF_PAGEALIGN(end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> error = vm_brk_flags(start, end - start,</span><br><span class="line"></span><br><span class="line">                prot &amp; PROT_EXEC ? VM_EXEC : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面，主要做了两件事情：<br>（1）为bss段分配虚拟内存空间，我们知道bss段不占用文件大小空间，在装载的时候再为其分配虚拟内存空间，这里就是办了这件事；<br>（2）初始化堆的指针，此时堆还是空的，所以，堆的开始地址start_brk和结束地址brk都设置成了同一个值。</p>
<p>栈的初始化其实在加载Segment之前已经完成，详见前文。</p>
<h2 id="跳转到程序入口"><a href="#跳转到程序入口" class="headerlink" title="跳转到程序入口"></a>跳转到程序入口</h2><p>在elf文件头中已经记录了入口地址，如果不是动态链接加载的情况，入口地址就是这个。</p>
<p>如果是动态链接，那么由动态链接先加载运行，然后再调回到程序的代码入口地址。主要代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (interpreter) &#123;</span><br><span class="line"></span><br><span class="line">	elf_entry = load_elf_interp(interp_elf_ex,</span><br><span class="line"></span><br><span class="line">					interpreter,</span><br><span class="line"></span><br><span class="line">					load_bias, interp_elf_phdata,</span><br><span class="line"></span><br><span class="line">					&amp;arch_state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR((<span class="type">void</span> *)elf_entry)) &#123;</span><br><span class="line"></span><br><span class="line">		interp_load_addr = elf_entry;</span><br><span class="line"></span><br><span class="line">		elf_entry += interp_elf_ex-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reloc_func_desc = interp_load_addr;</span><br><span class="line"></span><br><span class="line">	allow_write_access(interpreter);</span><br><span class="line"></span><br><span class="line">	fput(interpreter);</span><br><span class="line"></span><br><span class="line">	kfree(interp_elf_ex);</span><br><span class="line"></span><br><span class="line">	kfree(interp_elf_phdata);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">	elf_entry = e_entry;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//跳转到程序入口开始执行</span></span><br><span class="line">start_thread(regs, elf_entry, bprm-&gt;p);</span><br></pre></td></tr></table></figure>

<p>至此，程序装载完毕，我们的程序也成功的跑起来了。</p>
<p>注：文中内核代码为linux5.4版本</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/21/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">程序是如何跑起来的-静态链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-21 14:42:46 / 修改时间：14:43:13" itemprop="dateCreated datePublished" datetime="2023-07-21T14:42:46+08:00">2023-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>编译的最后一步就是链接，链接分为静态链接和动态链接，我们先讲静态链接。<br>所谓链接，就是把各个目标文件组装合并成一个可执行文件。<br>链接主要分为两步，第一步进行目标文件的合并，并进行空间地址分配；第二步就是符号解析和重定位。我们就主要分析下这个过程。<br>从前面我们知道，一个目标文件中由多个段组成，典型的有.text段，.data段，.bss段。那么链接过程如何把它们粘在一起呢？</p>
<h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><h2 id="顺序叠加"><a href="#顺序叠加" class="headerlink" title="顺序叠加"></a>顺序叠加</h2><p>最容易想到的方法就是直接叠加的方法，就多个目标文件直接拼接，如下图所示：</p>
<p><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-18-2009.png"></p>
<p>但是这样有一个很大的缺点就是最后的文件被分割成了很多个段，显得非常零散。而且，也非常浪费空间，因为在装载的时候，每一个段都会对应一个空间地址和对齐要求，一般情况下，会要求4k对齐（页对齐），这样，一个段不管多大，都会占用整数页，会产生大量内存碎片，浪费空间。</p>
<h2 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h2><p>另一种方法就是将各个目标文件的相似段合并成一个段，如下图所示<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-24-2009.png"></p>
<p>目前的连接器都是采用的这种合并方式。链接器首先扫描所有的输入目标文件，获取它们各个段的信息，并收集所有的符号统一放到一个全局符号表，然后进行符号解析和重定位等操作。</p>
<p>来看个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>; </span><br><span class="line">    <span class="type">int</span> c = add(a, g_b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="type">int</span> g_b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，将a.o和b.o链接起来<br>aarch64-none-linux-gnu-ld a.o b.o -e main -o ab<br>然后我们看看链接前后的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -h a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000038  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000078  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000078  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000005e  0000000000000000  0000000000000000  00000078  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d6  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000038  0000000000000000  0000000000000000  000000d8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aarch64-none-linux-gnu-objdump -h b.o</span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000020  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  00000060  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000005e  0000000000000000  0000000000000000  00000064  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000c2  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000030  0000000000000000  0000000000000000  000000c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aarch64-none-linux-gnu-objdump -h ab</span><br><span class="line"></span><br><span class="line">ab:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000058  0000000000400120  0000000000400120  00000120  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .eh_frame     00000050  0000000000400178  0000000000400178  00000178  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .data         00000004  0000000000410fe8  0000000000410fe8  00000fe8  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .comment      0000005d  0000000000000000  0000000000000000  00000fec  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h2><p>链接的一个重要工作就是给可执行文件分配地址空间，程序运行在内存中，所以就需要分配地址，这里一般都是指虚拟地址。<br>上面查看elf文件信息时，可以看到有个VMA和LMA，这里的VMA就是分配的虚拟地址，LMA是加载地址，一般情况下这两个地址是一样，但是在一些嵌入式系统中，程序要放在ROM中，LMA和VMA是不一样的，程序会先加载到ROM中，然后从ROM搬到内存执行。<br>这里我们关注VMA，可以看到链接之前VMA都是0，此时还没有分配地址，链接之后各个段都分配了响应的虚拟地址，.text段被分配到了地址0x400120，大小为0x58字节。<br>为什么链接器给可执行文件分配的地址会这么大呢，为什么不是从0开始呢？这里涉及一些虚拟地址空间分配的规则，在linux下，64位系统，elf可执行文件默认从地址0x400000开始分配。这块后面还会细讲。</p>
<p>完成地址分配后，各个符号的地址也就确定了，各个段内的符号相对各个段的偏移是固定的，那么经过缝合后，段的首地址确定了，那么符号的地址也就确定了。</p>
<h1 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h1><h2 id="重定位-1"><a href="#重定位-1" class="headerlink" title="重定位"></a>重定位</h2><p>完成空间分配后，就进入到静态链接的重要一环，符号解析和重定位。<br>为什么需要重定位呢？我们首先来看下a.o的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">   4:	910003fd 	mov	x29, sp</span><br><span class="line">   8:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">   c:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  10:	90000000 	adrp	x0, 0 &lt;g_b&gt;</span><br><span class="line">  14:	91000000 	add	x0, x0, #0x0</span><br><span class="line">  18:	b9400000 	ldr	w0, [x0]</span><br><span class="line">  1c:	2a0003e1 	mov	w1, w0</span><br><span class="line">  20:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  24:	94000000 	bl	0 &lt;add&gt;</span><br><span class="line">  28:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  2c:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  30:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  34:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看看ab的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d ab</span><br><span class="line"></span><br><span class="line">ab:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000400120 &lt;main&gt;:</span><br><span class="line">  400120:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">  400124:	910003fd 	mov	x29, sp</span><br><span class="line">  400128:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">  40012c:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  400130:	90000080 	adrp	x0, 410000 &lt;add+0xfea8&gt;</span><br><span class="line">  400134:	913fa000 	add	x0, x0, #0xfe8</span><br><span class="line">  400138:	b9400000 	ldr	w0, [x0]</span><br><span class="line">  40013c:	2a0003e1 	mov	w1, w0</span><br><span class="line">  400140:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  400144:	94000005 	bl	400158 &lt;add&gt;</span><br><span class="line">  400148:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  40014c:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  400150:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  400154:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">0000000000400158 &lt;add&gt;:</span><br><span class="line">  400158:	d10043ff 	sub	sp, sp, #0x10</span><br><span class="line">  40015c:	b9000fe0 	str	w0, [sp, #12]</span><br><span class="line">  400160:	b9000be1 	str	w1, [sp, #8]</span><br><span class="line">  400164:	b9400fe1 	ldr	w1, [sp, #12]</span><br><span class="line">  400168:	b9400be0 	ldr	w0, [sp, #8]</span><br><span class="line">  40016c:	0b000020 	add	w0, w1, w0</span><br><span class="line">  400170:	910043ff 	add	sp, sp, #0x10</span><br><span class="line">  400174:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比较两个main的汇编，发现有几处不同，a.o中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10:	90000000 	adrp	x0, 0 &lt;g_b&gt;</span><br><span class="line">14:	91000000 	add	x0, x0, #0x0</span><br></pre></td></tr></table></figure>
<p>和ab中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400130:	90000080 	adrp	x0, 410000 &lt;add+0xfea8&gt;</span><br><span class="line">400134:	913fa000 	add	x0, x0, #0xfe8</span><br></pre></td></tr></table></figure>
<p>还有就是a.o中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24:	94000000 	bl	0 &lt;add&gt;</span><br></pre></td></tr></table></figure>
<p>和ab中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400144:	94000005 	bl	400158 &lt;add&gt;</span><br></pre></td></tr></table></figure>

<p>adrp这条指令的作用获得变量当前页的基址，然后利用一条add指令加上变量在页内的偏移获得变量的地址。a.c在编译的时候显然是不知道外部变量g_b的地址的，所以，它就默认讲其地址设置为0。同样，add的地址也不知道，所以bl指令后面的地址也默认为0。</p>
<p>编译器不知道外部变量的地址，所以就先用0替代，然后链接器负责将其修正到正确的地址。</p>
<p>那么链接器是如何做的呢，它怎么知道哪些指令需要修正呢？其实每个elf文件都有一个重定位表，用以专门保存跟重定位相关的信息。elf文件中，每个重定位表基本都对应了一个重定位段，一个elf文件中可能存在多个重定位段。比如代码段“.text”如果有要被重定位的地方，就会有一个叫”.rel.text“的重定位段，相应的如果”.data”段中有需要重定位的地方，就会有一个“.rel.data”的重定位段。</p>
<p>我们来看下a.o的重定位表是怎样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000010 R_AARCH64_ADR_PREL_PG_HI21  g_b</span><br><span class="line">0000000000000014 R_AARCH64_ADD_ABS_LO12_NC  g_b</span><br><span class="line">0000000000000024 R_AARCH64_CALL26  add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">000000000000001c R_AARCH64_PREL32  .text</span><br></pre></td></tr></table></figure>

<p>这里展示了a.o里所有需要重定位的地方。每个要被重定位的地方叫一个重定位入口，每个入口前面的offset指的就是需要重定位的地方在段中的位置，RELOCATION RECORDS FOR [.text]指的就是代码段的重定位表。<br>重定位表在elf中也对应了一个数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_rel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr r_offset;  <span class="comment">/* Location at which to apply the action */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword r_info; <span class="comment">/* index and type of relocation */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure>
<p>r_offset 就是重定位入口的偏移，r_info是指重定位的类型，下面指令修正部分会涉及。</p>
<p>重定位的过程其实也是一个符号解析的过程，每个elf文件都有一个自己的符号表，查看a.o的符号表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -s a.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    7 $d</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">    10: 0000000000000000    56 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND g_b</span><br><span class="line">    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND add</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到g_b和add是属于UND符号，也就是undefined，说明当前目标文件中没有它们的重定位项，链接器在链接过程中，会扫描所有的输入目标文件，如果这些未定义的符号没有在全局符号表中找到，那么就会报符号未定义错误。这也是我们开发过程中编译最常见的一种错误，一般都是没有链接某个库导致。</p>
<h2 id="指令修正"><a href="#指令修正" class="headerlink" title="指令修正"></a>指令修正</h2><p>找到了需要重定位的指令之后，就需要将默认的符号地址修正成正确的目标地址。对于指令的修正方式不同的处理器会有不同的方式。比如arm64 体系结构的一些重定位类型：</p>
<ol>
<li>R_AARCH64_ABS64：绝对64位地址重定位类型。</li>
<li>R_AARCH64_ABS32：绝对32位地址重定位类型。</li>
<li>R_AARCH64_ABS16：绝对16位地址重定位类型。</li>
<li>R_AARCH64_PREL64：相对64位地址重定位类型。</li>
<li>R_AARCH64_PREL32：相对32位地址重定位类型。</li>
<li>R_AARCH64_PREL16：相对16位地址重定位类型。</li>
<li>R_AARCH64_ADR_PREL_PG_HI21：将相对地址的高21位转换为页对齐的高位。</li>
<li>R_AARCH64_ADR_PREL_PG_HI21_NC：非连续版本的R_AARCH64_ADR_PREL_PG_HI21。</li>
<li>R_AARCH64_ADD_ABS_LO12_NC：将相对地址的低12位转换为绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST8_ABS_LO12_NC：将相对地址的低12位转换为8位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST16_ABS_LO12_NC：将相对地址的低12位转换为16位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST32_ABS_LO12_NC：将相对地址的低12位转换为32位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST64_ABS_LO12_NC：将相对地址的低12位转换为64位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_CALL26：将相对于当前指令位置的26位相对地址转换为绝对地址</li>
</ol>
<p>基本操作如下：</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>操作</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>R_AARCH64_ADR_PREL_PG_HI21</td>
<td>Page(S+A)-Page(P)</td>
<td>X[31:12]</td>
</tr>
<tr>
<td>R_AARCH64_ADD_ABS_LO12_NC</td>
<td>S+A</td>
<td>X[11:0]</td>
</tr>
<tr>
<td>R_AARCH64_CALL26</td>
<td>S+A-P</td>
<td>X[27:2]</td>
</tr>
</tbody></table>
<p>其中，S表示要重定位的符号的运行时地址，A是重新安置的加数，P是重定位站点的地址(派生自r_offset)。<code>Page(expr)</code>是表达式expr的页面地址。</p>
<p>根据这个计算出来，第一条重定位的指令修正后地址就是0x410000。bl指令对应的R_AARCH64_CALL26，计算出来后，偏移是5。（（目标地址 - 指令地址）/ 4 = 偏移）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%9A%84%E8%87%AA%E5%BC%BA%E8%BF%90%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%9A%84%E8%87%AA%E5%BC%BA%E8%BF%90%E5%8A%A8/" class="post-title-link" itemprop="url">中国近代史的自强运动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-13 11:22:04 / 修改时间：11:22:31" itemprop="dateCreated datePublished" datetime="2023-04-13T11:22:04+08:00">2023-04-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>说起中国近代史，大家都知道那是一段中国的屈辱史，各种不平等条约，各种割地赔款，简直不忍直视。大家看了这段历史，不一而同的都会喷清王朝的腐败和黑暗，然而在这段屈辱的历史里，我们也涌现出了一些自强运动，虽然方式不同，但都在努力让这个国家变强。本文主要就是聚焦于在这段历史大背景下兴起的一系列自强运动。</p>
<p>说到中国近代史，就离不开鸦片战争，那是近代史的开端，也是屈辱的开端，说到鸦片战争，就离不开林则徐。<br>大家都知道林则徐主导了广东虎门销烟，是禁烟英雄，但其实林则徐不仅仅只是一位禁烟英雄，在当时，林则徐也算是少数几位能够放眼看世界的人物之一。<br>林则徐几乎每天都会让翻译给他翻译各种外文资料，通过这些资料，他对英国贸易有了一些了解，也知道了英国商人的大体背景。然而，林则徐获取的资料也只能是一些公开的资料，再加上当时的大背景下，大清朝缺乏一个深谙当今外交事务的官员，同样也包括林则徐在内，就很难从这些资料中判断出有什么有价值的线索。<br>同时，林则徐所接受的也是最为传统的中国教育，很难从更高的角度来看待世界性问题，所以也有很多人批评林则徐，认为他作为一名有思想的政治家，应当有更高的眼光，应当有负责任的态度，善于将自发的斗争纳入正确的轨道。但其实在当时的大背景下，要做到这样，非常难。</p>
<p>鸦片战争结束了，失败不是最重要的，最重要的应该是反思失败，从失败中汲取教训，很可惜，失败引出的只是”顺夷“而不是”制夷“。鸦片战争中负有重大责任的顶级人物，没有一个做出该有的反省。</p>
<p>如此对待，第二次鸦片战争的失败也就是板上钉钉的是事了。<br>英法联军攻入北京城，火烧圆明园，最后通过谈判，签订不平等的《北京条约》解决。<br>第二次鸦片战争结束后，主导处理战后事宜的恭亲王和文祥从他们的经验里得到了一些教训：首先，他们认识到了西方的武器比我们先进很多，练兵的方法也在我们之上，因为当时大清有名的大将僧格林沁和胜保在英法联军面前也是惨败；其次，他们发现西洋人不但愿意卖武器给我们，还愿意将它们的制造方法以及练兵方法都教给我们；最后，通过他们与西洋人的打交道过程中，发现西洋人并非不守信义之徒。<br>鉴于这些经验，恭亲王和文祥觉得中国必须自强，而且也有自强的机会。于是他们就制定了大致的方略：第一，就是以夷制夷，用西洋人的武器和方法来对付西洋人。于是他们开始购买西洋武器，请外交教官训练士兵。第二，他们认识到自强不是一个短期的过程，所以在自强达到预期目标之前，中国应该谨守条约以避免再次战争，可以说，这是一个隐忍自强的过程。<br>可以说，恭亲王和文祥能够认识到这些是非常不简单的，不仅有认识，他们还敢于付诸实践，敢于大胆前进，给中国寻找新的出路，拉开了近代中国自强的序幕，也就是近代中国著名的洋务运动。</p>
<p>提到洋务运动，那就离不开李鸿章，从历史课本中，我们对李鸿章的印象基本停留在他的北洋舰队在甲午海战中全军覆没，导致签订中日《马关条约》，同时后来的《辛丑条约》也是出自他手，于是他被很多人骂成了卖国贼。</p>
<p>其实，李鸿章是一位颇有远见的人。在镇压太平天国运动过程中，他也认识到了西洋武器的先进，在给曾国藩的信中，就写道：</p>
<blockquote>
<p>鸿章尝往英、法提督兵权，见其大炮之精纯，子药之细巧，器械之鲜明，队伍之雄整，实非中国所能及……深以中国军器远逊外洋为耻，日戒谕将士虑心忍辱，学得西人一二秘法，期有增益……若驻上海久而不能资取洋人长技，咎悔多矣。</p>
</blockquote>
<p>他也认识到了时下的中国必须改变，必须变革，在给恭亲王的信中，又写道：</p>
<blockquote>
<p>鸿章窃以为天下事穷则变，变则通。中国士大夫沉浸于章句小楷之积习，武夫悍卒又多粗蠢而不加细心，以致用非所学，学非所用。无事则斥外国之利器为奇技淫巧，以为不必学；有事则惊外国之利器为变怪神奇，以为不能学。不知洋人视火器为身心性命之学者已数百年。一旦豁然贯通，参阴阳而配造化，实有指挥如意，从心所欲之快……前者英、法各国，以日本为外府，肆意诛求。日本君臣发愤为雄，选宗室及大臣子弟之聪秀者，往西国制造厂师习各艺，又购制器之器，在本国制习。现在已能驾驶轮船，造放炸炮。去年英人虚声恫愒，以兵临之。然英人所恃而为攻战之利者，彼已分擅其长，用是凝然不动而英人固无如之何也。夫今之日本即明之倭寇也，距西国远而距中国近。我有以自立，则将附丽于我，窥伺西人之短长；我无以自强，则并效尤于彼，分西人之利薮。日本以海外区区小国，尚能及时改辙，知所取法。然则我中国深维穷权而通之故，夫亦可以皇然变计矣……杜挚有言曰：利不百，不变法；功不十，不易器。苏子瞻曰：言之于无事之时，足以为名，而恒苦于不信；言之于有事之时，足以见信，而已苦于无及。鸿章以为中国欲自强则莫如学习外国利器。欲学习外国利器则莫如觅制器之器，师其法而不必尽用其人。欲觅制器之器，与制器之人，则我专设一科取士，士终身悬以为富贵功名之鹄，则业可成，业可精，而才亦可集。</p>
</blockquote>
<p>从这些可以看出，李鸿章已经认识到了当时的中国只有学习外国的先进科学技术才能生存，更加难能可贵的是，他在1864年就已经看到中国和日本谁更强，就看谁变得更快，因为他看到了日本的明治维新给日本带来了巨大的改变。更进一步，他认为改革更要改教育，要改革传统的科举制度，他要士大夫们放弃文章，而要更加重视科学工程。从这些不难看出李鸿章的伟大。</p>
<p>洋务运动中，李鸿章也做了不少实事，这里就不一一列举，比如，在上海设外国语学校，在天津设机器制造局，设轮船招商局，修建铁路，创建北洋舰队，购买国外军舰，等等。</p>
<p>洋务运动的主要特点就是大部分事业都是国防事业，当然这也好理解，毕竟当时考虑的更多就是让中国能够在军事上自强起来。<br>但是，现代化的国防事业绝非那么简单，牵扯甚多，在这个过程中，洋务运动的首脑们也是在一步一步的前进，发现问题，解决问题。<br>比如，现代军事需要现代化的武器，这就需要机械制造厂，于是江南和天津机械制造厂应运而生；现代军队需要现代交通，第一次鸦片战争，由于交通落后，跨省调兵差不多要一个多月，甚至几个月才能到达前线，援兵到，战都早打完了，所以造船厂，电报局，铁路都开始建设；还有关键的人才，所以又设置了出洋留学机制；大量的现代建设，需要大量的费用，于是，又创办招商局，开始开采煤矿。<br>总之，洋务运动开始并没有一个宏大的纲领，而是首脑们一步一步慢慢走出来的。</p>
<p>当然，洋务运动并没有获得成功，可以说，甲午海战的失败，基本宣告洋务运动的失败。<br>为什么洋务运动最终还是失败了呢？最主要的还是在于变革不彻底。<br>首先，运动首脑们都是接受的旧教育，除了李鸿章，其他人连国外都没有去过，他们能够接受学习国外的先进技术，但是要引进政治制度，那是绝无可能的，他们始终坚信中国的政治制度是正确的。比如，为了修建颐和园，李鸿章不得不把建军的款子移作修颐和园之用，导致甲午海战之前的七年，海军没有增添过一只新船，如果有现代政治制度，这种事情就不会发生。<br>其次，当时的政府缺乏审计制度，贪腐丛生，就算是李鸿章，也不廉洁，更何况他底下的其他人。<br>还有就是李鸿章本人知识的缺乏，他让非专业人士领导专业人士的典型就是所用的海军总司令是个全不知海军的丁汝昌，丁氏原是淮军带马队的，这也为失败埋下了伏笔。</p>
<p>甲午海战结束了，洋务运动也失败了，但这并没有阻挡中国想自强的决心，特别是甲午海战的失败，对国内民众刺激甚大，曾经一直是中国小弟的日本，居然打败了我们，让人难以接受，要变革的呼声也越来越高。<br>观中国历史，有一个传统，就是祖宗之法不可变，先贤定下的制度，就要历代相传，不可改变，但凡要改革，阻力必然巨大。西汉和东汉中间的王莽改新失败，宋朝的王安石变法也失败了。<br>这个时候，康有为也发现了这个问题所在，他知道要改革，必须要冲突这道思想关卡，所以他就从孔子出发，写了一篇《孔子改制考》，提出孔子本身就是一个改革家，孔子作《春秋》的目的就是在于改革法制。同时，康有为又不断的上书当时的光绪帝，大谈救国之道。年轻的光绪帝，也很想有一番作为，于是决定重用康有为，开始了著名的戊戌变法，也就是百日维新。<br>百日维新的新政最重要的两件事就是：第一，以后的考试不再考八股文，而是政治经济的策论，总之就是读书人要重视真才实学；第二，调整政府机构，裁汰了一些无用的衙门，增添了一个类似经济部的农工商总局，以推动经济建设。<br>相对来说，百日维新比洋务运动更加西化，更加现代化，它已经开始触及到了政治改革。<br>但我们知道，戊戌变法很快就失败了，最主要的原因就在于当时的权力中心并不在皇帝，而是在慈禧太后，而慈禧太后正是顽固派的代表。</p>
<p>戊戌变法也失败了，说明中国需要的是一场彻底的革命。历史推出了孙中山先生，他领导的辛亥革命最终结束了清王朝的统治，真正的改变了中国。<br>孙中山从小就出国留学，一直接受的教育就是科学的教育，接受的是科学的思想方法，这些都让他对现代化的认识远在那些洋务运动领袖之上。<br>中山先生认识到只有彻底的革命，只有推翻腐朽的清王朝，才能救中国。他创建了同盟会，并说明革命应分军法、约法、宪法三时期，他说：</p>
<blockquote>
<p>由军政时期一蹴而至宪政时期，绝不予革命政府以训练人民之时期，又绝不予人民以养成自治能力之时间，于是第一流弊在旧污未由荡涤，新治未由进行；第二流弊在粉饰旧污以为新治；第三流弊在发扬旧民，压抑新治。更端言之，即第一，民治不能实现；第二，为假民治之名行专制之实；第三，则并民治之名而去之矣。此所谓事有必至，理有固然者。</p>
</blockquote>
<p>革命党们发起了很多革命活动：<br>1906年，同盟会的会员蔡绍南、刘道一联合湖南和江西交界的秘密会党在浏阳和萍乡起事，这是同盟会成立以后的第一次革命。<br>1907年，光复会首领徐锡麟杀安徽巡抚恩铭，此事牵连了他的同志秋瑾，两人终皆遇害。<br>1907年10月，熊成基带安徽新军一部分突破安庆。他虽失败了，他的行动表明长江一带的新军已受了革命思想的影响。<br>1910年2月，汪精卫和黄复生秘密地进北京，谋刺摄政王载沣失败。<br>最终在1911年10月，下级军官熊秉坤率队直入武昌，进攻总督衙门。总督瑞澂和文武官吏均弃城逃走，武昌便为革命军所据。黎元洪做起了革命军的都督。这便是著名的武昌起义，辛亥革命也就由此爆发，形成了全国性的革命运动，最终推翻了清王朝的统治。</p>
<p>辛亥革命虽然胜利了，但也仅仅在于推翻了清王朝，若要建设国家，仍有大量的障碍需要跨越。这些都已不再是本文的内容。</p>
<p>今天，我们一提起近代史，都是痛恨加痛惜，但是在痛恨的同时，我们也不应忘记那些在当时的艰难环境下仍然坚持要自强的人们，中华民族为何能够如此坚韧，为何能够屹立几千年而不断，我想也就在于此。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">程序是如何跑起来的-目标文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-13 11:16:38 / 修改时间：11:17:48" itemprop="dateCreated datePublished" datetime="2023-04-13T11:16:38+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目标文件是编译器生成的中间文件，包含了编译后的程序代码以及相关的元数据信息。目标文件在编译的过程中扮演了重要的角色，它们是编译器将源代码转换为可执行文件的重要组成部分。</p>
<h1 id="目标文件的类型"><a href="#目标文件的类型" class="headerlink" title="目标文件的类型"></a>目标文件的类型</h1><p>不同平台下目标文件格式会有所不同，比如windows下的PE，Linux下的ELF。可执行文件和目标文件的文件格式是同一种，Linux下都是ELF文件。</p>
<p>其实除了可执行文件，可重定位文件和共享目标文件都是ELF格式。</p>
<p>可重定位目标文件是指包含了程序代码和数据的二进制文件，它可以被链接器用于生成可执行文件或共享库。可重定位目标文件是编译器生成的默认文件类型。</p>
<p>可执行目标文件是指包含了完整程序代码和数据的二进制文件，它可以直接被操作系统加载并执行。</p>
<p>共享目标文件是指包含了可被多个程序共享的程序代码和数据的二进制文件，它可以被动态链接器加载到内存中，以便被多个进程共享。</p>
<p>Linux下可以用file命令来查看文件格式</p>
<h1 id="目标文件的组成"><a href="#目标文件的组成" class="headerlink" title="目标文件的组成"></a>目标文件的组成</h1><p>我们知道目标文件包含了我们程序的指令和数据，但是仅仅是这些吗？并不是的，除了指令和数据，我们还有符号表、调试信息等其他内容，同时，目标文件也会按照一定的方式来组织这些内容，按照不同的属性将这些信息组织成一个一个的段（Segment）。</p>
<p>这些段大致可以分为代码段（.text），数据段（.data)，BSS段(.bss)，符号表，调试信息等等。</p>
<p>一个C程序编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一叫.“bss”的段里。<br>为什么会有一个bss段呢，我们知道未初始化的全局变量和局部静态变量都会被初始化为0，它们本来可以放到data段，但是在data段存放数据0是没有必要的，因为程序运行的时候data段是要占据内存空间的，放在bss段，只是预留了一个位置，并没有内容，并不会占据空间，这样就能做到节省空间的目的。</p>
<p>那么为什么指令和数据要分开呢，放在一起不好吗？主要是基于以下几个原因：</p>
<ol>
<li>如果指令和数据放在一起，那么在程序被装载后，由于程序需要对数据进行读写，而指令部分是只读不写，那么这个写数据的过程就有可能因为误操作而改写了指令。分开后，数据和指令被映射到不同的区域，那么就可以针对这两个区域分别设置不同的权限。</li>
<li>第二个跟cpu的cache（缓存）有关，指令与数据分开有利于提高程序的局部性，提高cache的命中率。</li>
<li>第三个是节省空间的考虑，试想如果一个系统中运行着同一个程序的多个副本，这个时候如果指令和数据是混在一起的话，那么每个副本都需要有一份指令和数据，而如果分开的话，对于只读的指令，多个副本可以共享，这就节省了空间。</li>
</ol>
<p>对于目标文件的分析，我们来看一个用例（由于我主要基于arm平台进行开发，后面所有的分析都是基于arm平台，不过原理x86也是一样的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_blobal_val_init = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> g_blobal_val_uninit;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_uninit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_init = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    func(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只编译不链接得到目标文件SegmentTest.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -c SegmentTest.c </span><br></pre></td></tr></table></figure>

<p>对于目标文件的分析我们可以采用objdump工具，我们首先看变量所处位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -t SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，未初始化的全局变量g_blobal_val_uninit和局部静态变量static_val_uninit都在.bss段，初始化了的全局变量g_blobal_val_init和static_val_init在.data段。<br>再看下各个段的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -h SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000006c  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000ac  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000008  0000000000000000  0000000000000000  000000b4  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000008  0000000000000000  0000000000000000  000000b8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000005e  0000000000000000  0000000000000000  000000c0  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000011e  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000058  0000000000000000  0000000000000000  00000120  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看出，目标文件里，除了.data，.bss，.text，还有.rodata，.comment等其它段。同时我们能够大致看出elf文件的结构，因为这里展示了各个段的起始位置和大小，可能有的人发现了，为什么这里所有的段没有一个是从文件起始位置开始的，起始elf文件还存在在文件头，这个头是用来知识整个文件的信息的，后面会说。现在我们看到这个elf的结构如下：<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-03-27-2031.png"></p>
<p>各个段还有一些属性，其中”CONTENTS“属性表示该段是否在elf文件中存在，也就是是否有内容，我们可以看到.bss段没有这个属性，也就是说.bss段在elf文件中没有内容。</p>
<p>下面来分析下几个常见的段</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>代码段就是程序的指令，可以通过反汇编查看这些指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!</span><br><span class="line">   4:	910003fd 	mov	x29, sp</span><br><span class="line">   8:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">   c:	b9001be1 	str	w1, [sp, #24]</span><br><span class="line">  10:	b9401fe1 	ldr	w1, [sp, #28]</span><br><span class="line">  14:	b9401be0 	ldr	w0, [sp, #24]</span><br><span class="line">  18:	0b000020 	add	w0, w1, w0</span><br><span class="line">  1c:	b9002fe0 	str	w0, [sp, #44]</span><br><span class="line">  20:	b9402fe1 	ldr	w1, [sp, #44]</span><br><span class="line">  24:	90000000 	adrp	x0, 0 &lt;func&gt;</span><br><span class="line">  28:	91000000 	add	x0, x0, #0x0</span><br><span class="line">  2c:	94000000 	bl	0 &lt;printf&gt;</span><br><span class="line">  30:	b9402fe0 	ldr	w0, [sp, #44]</span><br><span class="line">  34:	a8c37bfd 	ldp	x29, x30, [sp], #48</span><br><span class="line">  38:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000000003c &lt;main&gt;:</span><br><span class="line">  3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">  40:	910003fd 	mov	x29, sp</span><br><span class="line">  44:	52800020 	mov	w0, #0x1                   	// #1</span><br><span class="line">  48:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  4c:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">  50:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  54:	b9401be1 	ldr	w1, [sp, #24]</span><br><span class="line">  58:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  5c:	94000000 	bl	0 &lt;func&gt;</span><br><span class="line">  60:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  64:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  68:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反汇编中第二列的十六进制数就是机器指令，可以看到，每一条汇编指令都对应了一条机器指令。还可以看到main函数中用bl跳转指令，跳到了func函数，func函数中同样用bl指令跳转到printf函数。</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>从上面我可以看到，数据段的大小是8个字节，刚好对应变量g_blobal_val_init和static_val_init。<br>这里顺便也提一下一个只读数据段，.rodata，这个段一般会存一些只读的变量和字符串常量。比如printf函数中的字符串常量”c=%d”，就在这个段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .data:</span><br><span class="line"> 0000 03000000 04000000                    ........        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 63203d20 25640a00                    c = %d..    </span><br></pre></td></tr></table></figure>
<p>在嵌入式开发中，一般会将.rodata段放在只读的ROM中，这样会保证这些数据不会被破坏。</p>
<h2 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h2><p>未初始化的全局变量和局部静态变量会放在.bss段，所以，上述g_blobal_val_uninit和static_val_uninit都在.bss段。</p>
<p>除了这几个常见的段，elf文件还有很多其他段，这里不再一一解释。</p>
<p>下面我们来看看如何自定义一个段，这在嵌入式开发中是一个非常常见的操作，特别是在一些裸驱的开发中。</p>
<h2 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h2><p>首先我们来看gcc提供的一个扩展机制，这个机制支持程序员将变量定义到一个特定的段上。<br>比如上面的代码加一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="type">int</span> sec_tst = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>编译后查看段信息，可以看到sec_tst在自定义的FOO段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  FOO	0000000000000000 FOO</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     O FOO	0000000000000004 sec_tst</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>裸驱开发中我们更多的会利用链接脚本（lds文件），在lds文件中定义好自己的段，然后在代码中定义变量时指定放在相应的段，特别是将某个段放到一块固定的地址上，这样一些信息放在这个段，后面调试查看相应变量的值直接到这个段的地址来看就行。<br>比如我们一个项目中就在dsp的ld文件中专门定义的一个段，专门用于存放软件版本信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN shram</span><br><span class="line">0xff000000: sysram : shram : 0x0100000 : executable, writable ;</span><br><span class="line"> shram0 : C : 0xff000000 - 0xff03ffff :  .loadM.data .loadM.bss;</span><br><span class="line"> shram1 : C : 0xff040000 - 0xff09fdff :  .shram.rodata .shram.literal .shram.text .shram.data .shram.bss;</span><br><span class="line"> shram2 : C : 0xff0ffc00 - 0xff0fffff :  .version.data .version.bss;</span><br><span class="line">END shram</span><br></pre></td></tr></table></figure>

<h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p>可执行文件是ELF文件格式，那么在程序运行的装载阶段，就必须解析这个文件，这样，就得知道ELF文件的组织结构。ELF文件分成4个部分：ELF首部、程序首部表<br>（program header table）、节（section）和节首部表（section header<br>table）。大致如下图所示<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h2 id="ELF首部"><a href="#ELF首部" class="headerlink" title="ELF首部"></a>ELF首部</h2><p>上面已经提到，ELF文件的开头是一个elf文件头信息。这个可以通过readelf工具查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -h SegmentTest.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1248 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br></pre></td></tr></table></figure>

<p>对应的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_type;  <span class="comment">/*elf 文件类型，1表示可重定位文件（目标文件），2表示可  </span></span><br><span class="line"><span class="comment">执行文件，3表示动态库，4表示核心转储文件*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_machine; <span class="comment">/* 机器类别，例如EM_ARM(40)表示ARM 32位，  </span></span><br><span class="line"><span class="comment">EM_AARCH64(183)表示ARM 64位*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_version;  <span class="comment">/*版本，用来区分不同的ELF变体*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr e_entry;   <span class="comment">/* 程序入口的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_phoff;    <span class="comment">/* 程序首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_shoff;    <span class="comment">/* 节首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_flags;   <span class="comment">/* 处理器特定的标志 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_ehsize;  <span class="comment">/* ELF首部的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phentsize; <span class="comment">/* 程序首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phnum;     <span class="comment">/* 程序首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shentsize;  <span class="comment">/* 节首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shnum;     <span class="comment">/* 节首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shstrndx;   <span class="comment">/* 节名称字符串表在节首部表中的索引 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<p>Linux内核加载ELF文件主要通过一个函数（具体装载过程后续会专门写）load_elf_binary（位于fs/binfmt_elf.c)进行。<br>第一步就是检查文件的头部信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elf_ex-&gt;e_type != ET_EXEC &amp;&amp; elf_ex-&gt;e_type != ET_DYN)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!elf_check_arch(elf_ex))</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>段表（segment table）就是程序首部表，描述各个段信息。段（segment）是从运行的角度来描述的，节（section）是从链接的角度描述的，一个段可以包含多个节，通常我们会把节称为段，比如代码段（text section），具体后续会有讲。<br>段表描述各个段的信息，编译器、连接器和装载器都是靠段表来定位和访问各个段的信息的。<br>段表也有一个对应的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_type;     <span class="comment">/*段的类型，常见的段类型如下。  </span></span><br><span class="line"><span class="comment">						可加载段（PT_LOAD，类型值为1）  </span></span><br><span class="line"><span class="comment">						解释器段（PT_INTERP，类型值为3）*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_flags;    <span class="comment">/* 段的标志，常用的3个权限标志是读、写和执行 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off p_offset;   <span class="comment">/* 段在文件中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_vaddr;   <span class="comment">/* 段的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_paddr;   <span class="comment">/* 段的物理地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_filesz;   <span class="comment">/* 段在文件中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_memsz;    <span class="comment">/* 段在内存中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_align;    <span class="comment">/* 段的对齐值 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<p>同样，节（section）也有对应的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_name;   <span class="comment">/* 节名称在节名称字符串表中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_type;   <span class="comment">/* 节的类型 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_flags;   <span class="comment">/* 节的属性 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr sh_addr;   <span class="comment">/* 节在执行时的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off sh_offset;    <span class="comment">/* 节的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_size;    <span class="comment">/* 节的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_link;   <span class="comment">/* 引用另一个节首部表表项，指定该表项的索引 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_info;   <span class="comment">/* 附加的节信息 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_addralign; <span class="comment">/* 节的对齐值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_entsize; <span class="comment">/* 如果节包含一个表项长度固定的表，例如符号表，那么这  </span></span><br><span class="line"><span class="comment">                            个成员存放表项的长度 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<p>我们可以分别用readelf -l和readelf -S查看elf文件的段表和节首部表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -S SegmentTest.o</span><br><span class="line">There are 13 section headers, starting at offset 0x4e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000006c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000003e8</span><br><span class="line">       0000000000000060  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000ac</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000b4</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000008  0000000000000000   A       0     0     8</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000c0</span><br><span class="line">       000000000000005e  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  0000011e</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000120</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000448</span><br><span class="line">       0000000000000030  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000178</span><br><span class="line">       00000000000001f8  0000000000000018          11    16     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000370</span><br><span class="line">       0000000000000072  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000478</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的Segment.o是编译后产生的.o文件，还没有链接，所以用了readelf -S来查看各个段（这里说的段其实是节，但是我们一般说段，上面已讲）的信息。总共有13个段，就是13个elf64_shdr结构的数组。<br>结合上面的头部信息，我们就大致知道了Segment.o的分布情况了<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>我们在编译代码的过程中，经常会遇到undefined symol的情况，一般都是某个函数没有定义，或者某个全局变量没有声明。<br>这里就提到了符号的概念，对于代码源文件，函数和变量都统称为符号，而链接的过程是把所有的目标文件粘合在一起，一个文件可能引用了其他文件中的符号，所以，目标文件就需要对符号做一个管理。每一个目标文件都会有一个对应的符号表，这个表里记录了目标文件中所用到的所有符号。<br>符号有多种，但我们关注主要就是定义在本文件的全局符号和在本文件引用的定义在其他文件中的全局符号。<br>可以使用nm命令查看目标文件的符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-nm SegmentTest.o</span><br><span class="line">0000000000000000 T func</span><br><span class="line">0000000000000000 D g_blobal_val_init</span><br><span class="line">0000000000000000 B g_blobal_val_uninit</span><br><span class="line">000000000000003c T main</span><br><span class="line">                 U printf</span><br><span class="line">0000000000000004 d static_val_init.1</span><br><span class="line">0000000000000004 b static_val_uninit.0</span><br></pre></td></tr></table></figure>

<h2 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h2><p>符号表在elf文件中一般是一个段，.symtab，符号表也对应一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word st_name;   <span class="comment">/* 符号名 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;  <span class="comment">/* 符号类型和绑定信息 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other; <span class="comment">/* 目前没用，为0 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half st_shndx;    <span class="comment">/* 符号所在的段 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr st_value;    <span class="comment">/* 符号对应的值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword st_size;    <span class="comment">/* 符号大小 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>我们来看一下这个符号类型和绑定信息，低4为表示符号类型，高4位为绑定信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_LOCAL  0  <span class="comment">//局部符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_GLOBAL 1  <span class="comment">//全局符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_WEAK   2  <span class="comment">//弱符号</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//符号类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_NOTYPE  0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_OBJECT  1   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FUNC    2   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_SECTION 3   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FILE    4   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_COMMON  5   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_TLS     6</span></span><br></pre></td></tr></table></figure>

<p>我们再用readelf -s来看目标文件的符号信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -s SegmentTest.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 21 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS SegmentTest.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    3 $d</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">    10: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_val_init.1</span><br><span class="line">    11: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_val_uninit.0</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">    13: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    8 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    15: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">    16: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_blobal_val_init</span><br><span class="line">    17: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 g_blobal_val_uninit</span><br><span class="line">    18: 0000000000000000    60 FUNC    GLOBAL DEFAULT    1 func</span><br><span class="line">    19: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br><span class="line">    20: 000000000000003c    48 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个更加清晰，基本与上面的数据结构能够对应起来。</p>
<h2 id="弱符号和强符号"><a href="#弱符号和强符号" class="headerlink" title="弱符号和强符号"></a>弱符号和强符号</h2><p>首先我们先看一下弱符号和强符号的一些链接规则：</p>
<ol>
<li>不允许强符号被多次定义，如果有，则链接器报符号重复定义错误，这种情况我们经常遇到；</li>
<li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号；</li>
<li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比如目标文件A定义全局变量global为int型，占4个字节：目标文件B定义global为double型，占8个字节，那么目标文件A和B链接后，符号global占8个字节。</li>
</ol>
<p>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号，我们也可以通过gcc的__attribute__((weak))来定义一个强符号为弱符号。<br>比如这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) weak1 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，weak和weak2是弱符号，strong和main都是强符号。<br>同样，GCC可以使用__attribute__((weakref))这个扩展来声明一个外部函数的引用为弱引用。<br>连接器在处理弱符号时，如果符号未定义，链接器并不会报错，一般会默认其为0，所以如果调用一个未定义的弱符号函数，只有在运行时才会奔溃，这个需要特别小心。</p>
<p>那么为什么要有这个弱符号呢？这个对库是很有用的，比如我们在库中的某个函数需要放开给用户自定义，那么就可以在库里将这个函数定义成弱引用，如果用户重新定义了这个函数为强符号，那么在链接的时候就会选择用户的函数，如果用户没有重新定义，那就会采用库里默认的函数。</p>
<h2 id="常见的extern-“C”"><a href="#常见的extern-“C”" class="headerlink" title="常见的extern “C”"></a>常见的extern “C”</h2><p>最后讲一下我们开发中常见的extern “C”，这个是干啥用的呢，主要是一些代码是用C++开发的，但是要C兼容，比如一个库用C++开发，而用户用的是C开发，那么这个库的头文件就会用extern “C”修饰。</p>
<p>为什么需要这个呢？还是符号的原因。<br>C++编译生成的目标文件跟C生成的目标文件中符号规则不一样，比如上面的Segment.c用g++编译的话，func函数的符号就是_Z4funcii，而C生成的符号就是func，加extern “C”的目的就是告诉编译器不要生成C++形式的符号，而是C形式的符号，这样，用户在用C编译代码的时候，才能够找到符号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">程序是如何跑起来的-编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-24 13:53:19 / 修改时间：17:24:00" itemprop="dateCreated datePublished" datetime="2023-03-24T13:53:19+08:00">2023-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上次简单写了一个引言，接下来我们就从编译开始。要说明下，本文不会深入讲解编译原理，那是一个非常大的课题，同时暂时不了解这些原理也不影响理解后面的内容。</p>
<p>为什么很多老手总是建议新手少用ide，其实也是有一定原因的，因为ide掩盖了很多事情。</p>
<p>就从ide上一个编译来说，这中间其实包含了几个步骤。</p>
<p>我们知道编译的作用就是将我们的源代码生成一个可执行文件。其实这中间包含了四个步骤：预编译、编译、汇编和链接。我们一步一步的来看。</p>
<h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><p>这是编译的第一步，这一步主要处理以#开头的预编译指令，比如#include，#define等，大概会做如下事情：</p>
<ol>
<li>将所有#include的头文件展开到当前文件；</li>
<li>展开所有的宏定义，也就是代码中#define的那些宏都会用值替代；</li>
<li>处理所有的#if …#else…#elif…#endif这些条件编译指令；</li>
<li>删除所有的注释；</li>
<li>添加行号和文件号标识，便于调试。</li>
</ol>
<p>gcc中预编译的指令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E</span><br></pre></td></tr></table></figure>

<p>我们用个例子来看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define A  1</span><br><span class="line">#define B  2</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = A;</span><br><span class="line">    int b = B;</span><br><span class="line"></span><br><span class="line">    int c = a + b;  /* add a and b, store the result to c */</span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行预编译指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>这样我们就将预编译的结果存在了test.i文件中，打开这个文件，发现内容非常多，其实看一下，就知道，前面都是头文件stdio.h的展开，因为stdio.h中又包含了其他头文件，这些头文件都会展开，所以test.i这个文件会比较大，我们提取一部分看下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">extern FILE *stdin;</span><br><span class="line">extern FILE *stdout;</span><br><span class="line">extern FILE *stderr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"></span><br><span class="line">extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int renameat (int __oldfd, const char *__old, int __newfd,</span><br><span class="line">       const char *__new) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"># 173 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *tmpfile (void) ;</span><br><span class="line"># 187 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"># 204 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern char *tempnam (const char *__dir, const char *__pfx)</span><br><span class="line">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int fclose (FILE *__stream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int fflush (FILE *__stream);</span><br><span class="line"># 227 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern int fflush_unlocked (FILE *__stream);</span><br><span class="line"># 246 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fopen (const char *__restrict __filename,</span><br><span class="line">      const char *__restrict __modes) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern FILE *freopen (const char *__restrict __filename,</span><br><span class="line">        const char *__restrict __modes,</span><br><span class="line">        FILE *__restrict __stream) ;</span><br><span class="line"># 279 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"># 292 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)</span><br><span class="line">  __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">extern int printf (const char *__restrict __format, ...);</span><br></pre></td></tr></table></figure>
<p>再看我们的main函数变成什么了，拉到test.i文件的最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line"></span><br><span class="line">    int c = a + b;</span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，定义的两个宏在代码中已经用宏的值替换了，注释也删除了。<br>以上我们就了解了预编译到底做了啥。</p>
<p>到这里，我们就可以来解释一个问题，就是我们在定义一个头文件的时候，一般都要采取如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef XXXX_H</span><br><span class="line">#define XXXX_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>为什么要这么做呢，防止重复包含头文件后的重复展开，导致函数声明重复。这样操作后，即便同一个头文件包含了多次，也只会展开一次，不会出现问题。</p>
<p>在嵌入式开发中，我们经常就会利用这种展开机制，嵌入式开发中经常出现没有文件系统的情况，比如一些mcu方案里，操作系统是一些轻量级的rtos，不存在文件系统，而我们测试的时候，经常会有一些输入数据和参考输出数据，没有文件系统，这些数据怎么读进去呢。这个时候，就需要把这些数据编进代码里，最简单的办法就是定义一个全局数据，然后数组初始化为这些测试数据。<br>但是如果测试数据比较多，那么这个源文件里看起来就是大量的数据，不是很友好。这个时候就可以把数据放在一个文件里，比如data.dat，然后在源文件中通过#include包含进来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int g_input_data[] = </span><br><span class="line">&#123;</span><br><span class="line">#include &quot;data.dat&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，更换输入也方便，只需要换个文件就可以了。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>预编译相当于对源文件做了一个预处理，接下来编译的工作就是将源代码翻译成汇编代码。<br>gcc中编译的命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S</span><br></pre></td></tr></table></figure>

<p>我们将刚刚得到的test.i编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>输出了汇编文件test.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;test.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;c = %d\n&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	$1, -12(%rbp)</span><br><span class="line">	movl	$2, -8(%rbp)</span><br><span class="line">	movl	-12(%rbp), %edx</span><br><span class="line">	movl	-8(%rbp), %eax</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	movl	%eax, -4(%rbp)</span><br><span class="line">	movl	-4(%rbp), %eax</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">	leaq	.LC0(%rip), %rdi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	printf@PLT</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">	.section	.note.gnu.property,&quot;a&quot;</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 1f - 0f</span><br><span class="line">	.long	 4f - 1f</span><br><span class="line">	.long	 5</span><br><span class="line">0:</span><br><span class="line">	.string	 &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 0xc0000002</span><br><span class="line">	.long	 3f - 2f</span><br><span class="line">2:</span><br><span class="line">	.long	 0x3</span><br><span class="line">3:</span><br><span class="line">	.align 8</span><br><span class="line">4:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gcc将预编译和编译两步合并了，其实这两步都是调用了cc1这个程序（位于 /usr/lib/gcc/x86_64-linux-gnu/9/cc1）。</p>
<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编是将编译出来的汇编代码翻译成计算机能够执行的机器代码，基本上一条汇编指令就会对应一条机器指令。<br>gcc中汇编的指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c</span><br></pre></td></tr></table></figure>
<p>gcc汇编的过程也是调用了汇编器as完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<p>生成的test.o就是机器代码文件，也叫目标文件。在很多源代码的工程中，编译后，我们往往能够看到，每一个源文件都会生成一个.o的目标文件。</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>目标文件生成了，但是目标文件并不能直接运行，还需要通过链接生成可执行文件。链接是很重要的一步，也特别复杂，这部分后面还会专门展开写，静态链接和动态链接。<br>gcc中链接由连接器collect2完成。<br>为什么刚才的目标文件不能直接运行呢？<br>我们先把刚才的test.c完整的编译成一个可执行程序a.out（gcc中不指定输出程序名的话，默认为a.out）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了可执行程序，这个a.out是可以直接运行的。现在再来分别反汇编一下a.out和刚才的test.o，看看两者的差异，反汇编可以用objdump工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s a.out &gt; a.s</span><br><span class="line">objdump -s test.o &gt; test.s</span><br></pre></td></tr></table></figure>
<p>你会看到，两个文件差异很多，a.out里明显多出了很多内容，这些内容就是链接时生成的，而且，没有这些内容，就没法运行。</p>
<p>到这里，我们终于得到了可执行文件，终于可以运行了。可见，ide上一个简单的编译操作，它的背后其实涵盖了很多内容。</p>
<p>接下来，就是运行了，一个简单的./a.out，这背后又会发生什么呢？这就得首先从可执行文件入手了，这就是下一次的主题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E5%BC%95%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E5%BC%95%E8%A8%80/" class="post-title-link" itemprop="url">程序是如何跑起来的-引言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 13:49:17" itemprop="dateCreated datePublished" datetime="2023-03-24T13:49:17+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-13 11:20:56" itemprop="dateModified" datetime="2023-04-13T11:20:56+08:00">2023-04-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学程序的人们最先接触的就是我们所熟知的Hello World程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello World!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先会在一个ide里（比如windows下的visual studio）敲下上述代码，然后点击编译按钮编译，完成后点击运行，就会在控制台里打印出Hello World。</p>
<p>但是，我们有没有想过，这中间到底发生了什么呢？为什么一定要编译呢，可能我们都知道计算机只认识二进制文件，需要把程序翻译成二进制代码，所以需要编译。<br>那编译直接就生成了二进制文件， 还是中间会发生其他事情呢？</p>
<p>对于一些工程，我们的源代码不会只有一个源文件，那么那么多的源文件最后又是怎么生成一个可执行文件的呢？</p>
<p>大的工程，还充斥着各种静态链接和动态链接，这些又是怎么回事呢？</p>
<p>编译得到了可执行程序，比如在linux shell下，执行一个可执行程序，打印出了一串信息，这背后又发生了什么呢？</p>
<p>其实这里更加复杂，我们知道一个运行着的程序就是一个进程，我们编译出来的程序也一样，首先就需要生成一个进程来运行我们的程序。</p>
<p>问题又来了，程序是一个二进制文件，进程怎么去运行这个二进制文件呢？这里面就涉及到了目标文件问题以及程序的装载问题。</p>
<p>还有，我们学习C或者C++的时候，都知道每个程序都必须要有一个main函数，main函数是整个程序的入口点。那为什么必须要有main函数呢？其实程序中的那些全部变量在main函数之前就已经完成初始化了，C++中的全局对象在main之前就完成构造了。</p>
<p>接下来，我就准备写一个系列的文章来理清楚我们的程序到底是如何跑起来的。这是一篇简单的引言，也希望自己能够坚持写下去。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 07:55:43" itemprop="dateCreated datePublished" datetime="2023-03-24T07:55:43+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-20 20:14:16" itemprop="dateModified" datetime="2023-03-20T20:14:16+08:00">2023-03-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WarmDad</p>
  <div class="site-description" itemprop="description">WarmDad的学习与生活记录空间</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WarmDad</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
