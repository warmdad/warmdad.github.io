<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Arial:300,300italic,400,400italic,700,700italic|Verdana:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="WarmDad的学习与生活记录空间">
<meta property="og:type" content="website">
<meta property="og:title" content="WarmDad&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="WarmDad&#39;s Blog">
<meta property="og:description" content="WarmDad的学习与生活记录空间">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="WarmDad">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>WarmDad's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WarmDad's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">程序是如何跑起来的-目标文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-13 11:16:38 / 修改时间：11:17:48" itemprop="dateCreated datePublished" datetime="2023-04-13T11:16:38+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目标文件是编译器生成的中间文件，包含了编译后的程序代码以及相关的元数据信息。目标文件在编译的过程中扮演了重要的角色，它们是编译器将源代码转换为可执行文件的重要组成部分。</p>
<h1 id="目标文件的类型"><a href="#目标文件的类型" class="headerlink" title="目标文件的类型"></a>目标文件的类型</h1><p>不同平台下目标文件格式会有所不同，比如windows下的PE，Linux下的ELF。可执行文件和目标文件的文件格式是同一种，Linux下都是ELF文件。</p>
<p>其实除了可执行文件，可重定位文件和共享目标文件都是ELF格式。</p>
<p>可重定位目标文件是指包含了程序代码和数据的二进制文件，它可以被链接器用于生成可执行文件或共享库。可重定位目标文件是编译器生成的默认文件类型。</p>
<p>可执行目标文件是指包含了完整程序代码和数据的二进制文件，它可以直接被操作系统加载并执行。</p>
<p>共享目标文件是指包含了可被多个程序共享的程序代码和数据的二进制文件，它可以被动态链接器加载到内存中，以便被多个进程共享。</p>
<p>Linux下可以用file命令来查看文件格式</p>
<h1 id="目标文件的组成"><a href="#目标文件的组成" class="headerlink" title="目标文件的组成"></a>目标文件的组成</h1><p>我们知道目标文件包含了我们程序的指令和数据，但是仅仅是这些吗？并不是的，除了指令和数据，我们还有符号表、调试信息等其他内容，同时，目标文件也会按照一定的方式来组织这些内容，按照不同的属性将这些信息组织成一个一个的段（Segment）。</p>
<p>这些段大致可以分为代码段（.text），数据段（.data)，BSS段(.bss)，符号表，调试信息等等。</p>
<p>一个C程序编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一叫.“bss”的段里。<br>为什么会有一个bss段呢，我们知道未初始化的全局变量和局部静态变量都会被初始化为0，它们本来可以放到data段，但是在data段存放数据0是没有必要的，因为程序运行的时候data段是要占据内存空间的，放在bss段，只是预留了一个位置，并没有内容，并不会占据空间，这样就能做到节省空间的目的。</p>
<p>那么为什么指令和数据要分开呢，放在一起不好吗？主要是基于以下几个原因：</p>
<ol>
<li>如果指令和数据放在一起，那么在程序被装载后，由于程序需要对数据进行读写，而指令部分是只读不写，那么这个写数据的过程就有可能因为误操作而改写了指令。分开后，数据和指令被映射到不同的区域，那么就可以针对这两个区域分别设置不同的权限。</li>
<li>第二个跟cpu的cache（缓存）有关，指令与数据分开有利于提高程序的局部性，提高cache的命中率。</li>
<li>第三个是节省空间的考虑，试想如果一个系统中运行着同一个程序的多个副本，这个时候如果指令和数据是混在一起的话，那么每个副本都需要有一份指令和数据，而如果分开的话，对于只读的指令，多个副本可以共享，这就节省了空间。</li>
</ol>
<p>对于目标文件的分析，我们来看一个用例（由于我主要基于arm平台进行开发，后面所有的分析都是基于arm平台，不过原理x86也是一样的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_blobal_val_init = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> g_blobal_val_uninit;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_uninit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_init = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    func(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只编译不链接得到目标文件SegmentTest.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -c SegmentTest.c </span><br></pre></td></tr></table></figure>

<p>对于目标文件的分析我们可以采用objdump工具，我们首先看变量所处位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -t SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，未初始化的全局变量g_blobal_val_uninit和局部静态变量static_val_uninit都在.bss段，初始化了的全局变量g_blobal_val_init和static_val_init在.data段。<br>再看下各个段的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -h SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000006c  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000ac  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000008  0000000000000000  0000000000000000  000000b4  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000008  0000000000000000  0000000000000000  000000b8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000005e  0000000000000000  0000000000000000  000000c0  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000011e  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000058  0000000000000000  0000000000000000  00000120  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看出，目标文件里，除了.data，.bss，.text，还有.rodata，.comment等其它段。同时我们能够大致看出elf文件的结构，因为这里展示了各个段的起始位置和大小，可能有的人发现了，为什么这里所有的段没有一个是从文件起始位置开始的，起始elf文件还存在在文件头，这个头是用来知识整个文件的信息的，后面会说。现在我们看到这个elf的结构如下：<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-03-27-2031.png"></p>
<p>各个段还有一些属性，其中”CONTENTS“属性表示该段是否在elf文件中存在，也就是是否有内容，我们可以看到.bss段没有这个属性，也就是说.bss段在elf文件中没有内容。</p>
<p>下面来分析下几个常见的段</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>代码段就是程序的指令，可以通过反汇编查看这些指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!</span><br><span class="line">   4:	910003fd 	mov	x29, sp</span><br><span class="line">   8:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">   c:	b9001be1 	str	w1, [sp, #24]</span><br><span class="line">  10:	b9401fe1 	ldr	w1, [sp, #28]</span><br><span class="line">  14:	b9401be0 	ldr	w0, [sp, #24]</span><br><span class="line">  18:	0b000020 	add	w0, w1, w0</span><br><span class="line">  1c:	b9002fe0 	str	w0, [sp, #44]</span><br><span class="line">  20:	b9402fe1 	ldr	w1, [sp, #44]</span><br><span class="line">  24:	90000000 	adrp	x0, 0 &lt;func&gt;</span><br><span class="line">  28:	91000000 	add	x0, x0, #0x0</span><br><span class="line">  2c:	94000000 	bl	0 &lt;printf&gt;</span><br><span class="line">  30:	b9402fe0 	ldr	w0, [sp, #44]</span><br><span class="line">  34:	a8c37bfd 	ldp	x29, x30, [sp], #48</span><br><span class="line">  38:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000000003c &lt;main&gt;:</span><br><span class="line">  3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">  40:	910003fd 	mov	x29, sp</span><br><span class="line">  44:	52800020 	mov	w0, #0x1                   	// #1</span><br><span class="line">  48:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  4c:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">  50:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  54:	b9401be1 	ldr	w1, [sp, #24]</span><br><span class="line">  58:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  5c:	94000000 	bl	0 &lt;func&gt;</span><br><span class="line">  60:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  64:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  68:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反汇编中第二列的十六进制数就是机器指令，可以看到，每一条汇编指令都对应了一条机器指令。还可以看到main函数中用bl跳转指令，跳到了func函数，func函数中同样用bl指令跳转到printf函数。</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>从上面我可以看到，数据段的大小是8个字节，刚好对应变量g_blobal_val_init和static_val_init。<br>这里顺便也提一下一个只读数据段，.rodata，这个段一般会存一些只读的变量和字符串常量。比如printf函数中的字符串常量”c=%d”，就在这个段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .data:</span><br><span class="line"> 0000 03000000 04000000                    ........        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 63203d20 25640a00                    c = %d..    </span><br></pre></td></tr></table></figure>
<p>在嵌入式开发中，一般会将.rodata段放在只读的ROM中，这样会保证这些数据不会被破坏。</p>
<h2 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h2><p>未初始化的全局变量和局部静态变量会放在.bss段，所以，上述g_blobal_val_uninit和static_val_uninit都在.bss段。</p>
<p>除了这几个常见的段，elf文件还有很多其他段，这里不再一一解释。</p>
<p>下面我们来看看如何自定义一个段，这在嵌入式开发中是一个非常常见的操作，特别是在一些裸驱的开发中。</p>
<h2 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h2><p>首先我们来看gcc提供的一个扩展机制，这个机制支持程序员将变量定义到一个特定的段上。<br>比如上面的代码加一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="type">int</span> sec_tst = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>编译后查看段信息，可以看到sec_tst在自定义的FOO段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  FOO	0000000000000000 FOO</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     O FOO	0000000000000004 sec_tst</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>裸驱开发中我们更多的会利用链接脚本（lds文件），在lds文件中定义好自己的段，然后在代码中定义变量时指定放在相应的段，特别是将某个段放到一块固定的地址上，这样一些信息放在这个段，后面调试查看相应变量的值直接到这个段的地址来看就行。<br>比如我们一个项目中就在dsp的ld文件中专门定义的一个段，专门用于存放软件版本信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN shram</span><br><span class="line">0xff000000: sysram : shram : 0x0100000 : executable, writable ;</span><br><span class="line"> shram0 : C : 0xff000000 - 0xff03ffff :  .loadM.data .loadM.bss;</span><br><span class="line"> shram1 : C : 0xff040000 - 0xff09fdff :  .shram.rodata .shram.literal .shram.text .shram.data .shram.bss;</span><br><span class="line"> shram2 : C : 0xff0ffc00 - 0xff0fffff :  .version.data .version.bss;</span><br><span class="line">END shram</span><br></pre></td></tr></table></figure>

<h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p>可执行文件是ELF文件格式，那么在程序运行的装载阶段，就必须解析这个文件，这样，就得知道ELF文件的组织结构。ELF文件分成4个部分：ELF首部、程序首部表<br>（program header table）、节（section）和节首部表（section header<br>table）。大致如下图所示<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h2 id="ELF首部"><a href="#ELF首部" class="headerlink" title="ELF首部"></a>ELF首部</h2><p>上面已经提到，ELF文件的开头是一个elf文件头信息。这个可以通过readelf工具查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -h SegmentTest.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1248 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br></pre></td></tr></table></figure>

<p>对应的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_type;  <span class="comment">/*elf 文件类型，1表示可重定位文件（目标文件），2表示可  </span></span><br><span class="line"><span class="comment">执行文件，3表示动态库，4表示核心转储文件*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_machine; <span class="comment">/* 机器类别，例如EM_ARM(40)表示ARM 32位，  </span></span><br><span class="line"><span class="comment">EM_AARCH64(183)表示ARM 64位*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_version;  <span class="comment">/*版本，用来区分不同的ELF变体*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr e_entry;   <span class="comment">/* 程序入口的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_phoff;    <span class="comment">/* 程序首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_shoff;    <span class="comment">/* 节首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_flags;   <span class="comment">/* 处理器特定的标志 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_ehsize;  <span class="comment">/* ELF首部的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phentsize; <span class="comment">/* 程序首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phnum;     <span class="comment">/* 程序首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shentsize;  <span class="comment">/* 节首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shnum;     <span class="comment">/* 节首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shstrndx;   <span class="comment">/* 节名称字符串表在节首部表中的索引 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<p>Linux内核加载ELF文件主要通过一个函数（具体装载过程后续会专门写）load_elf_binary（位于fs/binfmt_elf.c)进行。<br>第一步就是检查文件的头部信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elf_ex-&gt;e_type != ET_EXEC &amp;&amp; elf_ex-&gt;e_type != ET_DYN)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!elf_check_arch(elf_ex))</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>段表（segment table）就是程序首部表，描述各个段信息。段（segment）是从运行的角度来描述的，节（section）是从链接的角度描述的，一个段可以包含多个节，通常我们会把节称为段，比如代码段（text section），具体后续会有讲。<br>段表描述各个段的信息，编译器、连接器和装载器都是靠段表来定位和访问各个段的信息的。<br>段表也有一个对应的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_type;     <span class="comment">/*段的类型，常见的段类型如下。  </span></span><br><span class="line"><span class="comment">						可加载段（PT_LOAD，类型值为1）  </span></span><br><span class="line"><span class="comment">						解释器段（PT_INTERP，类型值为3）*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_flags;    <span class="comment">/* 段的标志，常用的3个权限标志是读、写和执行 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off p_offset;   <span class="comment">/* 段在文件中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_vaddr;   <span class="comment">/* 段的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_paddr;   <span class="comment">/* 段的物理地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_filesz;   <span class="comment">/* 段在文件中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_memsz;    <span class="comment">/* 段在内存中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_align;    <span class="comment">/* 段的对齐值 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<p>同样，节（section）也有对应的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_name;   <span class="comment">/* 节名称在节名称字符串表中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_type;   <span class="comment">/* 节的类型 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_flags;   <span class="comment">/* 节的属性 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr sh_addr;   <span class="comment">/* 节在执行时的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off sh_offset;    <span class="comment">/* 节的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_size;    <span class="comment">/* 节的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_link;   <span class="comment">/* 引用另一个节首部表表项，指定该表项的索引 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_info;   <span class="comment">/* 附加的节信息 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_addralign; <span class="comment">/* 节的对齐值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_entsize; <span class="comment">/* 如果节包含一个表项长度固定的表，例如符号表，那么这  </span></span><br><span class="line"><span class="comment">                            个成员存放表项的长度 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<p>我们可以分别用readelf -l和readelf -S查看elf文件的段表和节首部表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -S SegmentTest.o</span><br><span class="line">There are 13 section headers, starting at offset 0x4e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000006c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000003e8</span><br><span class="line">       0000000000000060  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000ac</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000b4</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000008  0000000000000000   A       0     0     8</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000c0</span><br><span class="line">       000000000000005e  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  0000011e</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000120</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000448</span><br><span class="line">       0000000000000030  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000178</span><br><span class="line">       00000000000001f8  0000000000000018          11    16     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000370</span><br><span class="line">       0000000000000072  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000478</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的Segment.o是编译后产生的.o文件，还没有链接，所以用了readelf -S来查看各个段（这里说的段其实是节，但是我们一般说段，上面已讲）的信息。总共有13个段，就是13个elf64_shdr结构的数组。<br>结合上面的头部信息，我们就大致知道了Segment.o的分布情况了<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>我们在编译代码的过程中，经常会遇到undefined symol的情况，一般都是某个函数没有定义，或者某个全局变量没有声明。<br>这里就提到了符号的概念，对于代码源文件，函数和变量都统称为符号，而链接的过程是把所有的目标文件粘合在一起，一个文件可能引用了其他文件中的符号，所以，目标文件就需要对符号做一个管理。每一个目标文件都会有一个对应的符号表，这个表里记录了目标文件中所用到的所有符号。<br>符号有多种，但我们关注主要就是定义在本文件的全局符号和在本文件引用的定义在其他文件中的全局符号。<br>可以使用nm命令查看目标文件的符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-nm SegmentTest.o</span><br><span class="line">0000000000000000 T func</span><br><span class="line">0000000000000000 D g_blobal_val_init</span><br><span class="line">0000000000000000 B g_blobal_val_uninit</span><br><span class="line">000000000000003c T main</span><br><span class="line">                 U printf</span><br><span class="line">0000000000000004 d static_val_init.1</span><br><span class="line">0000000000000004 b static_val_uninit.0</span><br></pre></td></tr></table></figure>

<h2 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h2><p>符号表在elf文件中一般是一个段，.symtab，符号表也对应一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word st_name;   <span class="comment">/* 符号名 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;  <span class="comment">/* 符号类型和绑定信息 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other; <span class="comment">/* 目前没用，为0 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half st_shndx;    <span class="comment">/* 符号所在的段 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr st_value;    <span class="comment">/* 符号对应的值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword st_size;    <span class="comment">/* 符号大小 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>我们来看一下这个符号类型和绑定信息，低4为表示符号类型，高4位为绑定信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_LOCAL  0  <span class="comment">//局部符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_GLOBAL 1  <span class="comment">//全局符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_WEAK   2  <span class="comment">//弱符号</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//符号类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_NOTYPE  0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_OBJECT  1   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FUNC    2   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_SECTION 3   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FILE    4   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_COMMON  5   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_TLS     6</span></span><br></pre></td></tr></table></figure>

<p>我们再用readelf -s来看目标文件的符号信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -s SegmentTest.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 21 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS SegmentTest.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    3 $d</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">    10: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_val_init.1</span><br><span class="line">    11: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_val_uninit.0</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">    13: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    8 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    15: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">    16: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_blobal_val_init</span><br><span class="line">    17: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 g_blobal_val_uninit</span><br><span class="line">    18: 0000000000000000    60 FUNC    GLOBAL DEFAULT    1 func</span><br><span class="line">    19: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br><span class="line">    20: 000000000000003c    48 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个更加清晰，基本与上面的数据结构能够对应起来。</p>
<h2 id="弱符号和强符号"><a href="#弱符号和强符号" class="headerlink" title="弱符号和强符号"></a>弱符号和强符号</h2><p>首先我们先看一下弱符号和强符号的一些链接规则：</p>
<ol>
<li>不允许强符号被多次定义，如果有，则链接器报符号重复定义错误，这种情况我们经常遇到；</li>
<li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号；</li>
<li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比如目标文件A定义全局变量global为int型，占4个字节：目标文件B定义global为double型，占8个字节，那么目标文件A和B链接后，符号global占8个字节。</li>
</ol>
<p>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号，我们也可以通过gcc的__attribute__((weak))来定义一个强符号为弱符号。<br>比如这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) weak1 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，weak和weak2是弱符号，strong和main都是强符号。<br>同样，GCC可以使用__attribute__((weakref))这个扩展来声明一个外部函数的引用为弱引用。<br>连接器在处理弱符号时，如果符号未定义，链接器并不会报错，一般会默认其为0，所以如果调用一个未定义的弱符号函数，只有在运行时才会奔溃，这个需要特别小心。</p>
<p>那么为什么要有这个弱符号呢？这个对库是很有用的，比如我们在库中的某个函数需要放开给用户自定义，那么就可以在库里将这个函数定义成弱引用，如果用户重新定义了这个函数为强符号，那么在链接的时候就会选择用户的函数，如果用户没有重新定义，那就会采用库里默认的函数。</p>
<h2 id="常见的extern-“C”"><a href="#常见的extern-“C”" class="headerlink" title="常见的extern “C”"></a>常见的extern “C”</h2><p>最后讲一下我们开发中常见的extern “C”，这个是干啥用的呢，主要是一些代码是用C++开发的，但是要C兼容，比如一个库用C++开发，而用户用的是C开发，那么这个库的头文件就会用extern “C”修饰。</p>
<p>为什么需要这个呢？还是符号的原因。<br>C++编译生成的目标文件跟C生成的目标文件中符号规则不一样，比如上面的Segment.c用g++编译的话，func函数的符号就是_Z4funcii，而C生成的符号就是func，加extern “C”的目的就是告诉编译器不要生成C++形式的符号，而是C形式的符号，这样，用户在用C编译代码的时候，才能够找到符号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">程序是如何跑起来的-编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-24 13:53:19 / 修改时间：17:24:00" itemprop="dateCreated datePublished" datetime="2023-03-24T13:53:19+08:00">2023-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上次简单写了一个引言，接下来我们就从编译开始。要说明下，本文不会深入讲解编译原理，那是一个非常大的课题，同时暂时不了解这些原理也不影响理解后面的内容。</p>
<p>为什么很多老手总是建议新手少用ide，其实也是有一定原因的，因为ide掩盖了很多事情。</p>
<p>就从ide上一个编译来说，这中间其实包含了几个步骤。</p>
<p>我们知道编译的作用就是将我们的源代码生成一个可执行文件。其实这中间包含了四个步骤：预编译、编译、汇编和链接。我们一步一步的来看。</p>
<h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><p>这是编译的第一步，这一步主要处理以#开头的预编译指令，比如#include，#define等，大概会做如下事情：</p>
<ol>
<li>将所有#include的头文件展开到当前文件；</li>
<li>展开所有的宏定义，也就是代码中#define的那些宏都会用值替代；</li>
<li>处理所有的#if …#else…#elif…#endif这些条件编译指令；</li>
<li>删除所有的注释；</li>
<li>添加行号和文件号标识，便于调试。</li>
</ol>
<p>gcc中预编译的指令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E</span><br></pre></td></tr></table></figure>

<p>我们用个例子来看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define A  1</span><br><span class="line">#define B  2</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = A;</span><br><span class="line">    int b = B;</span><br><span class="line"></span><br><span class="line">    int c = a + b;  /* add a and b, store the result to c */</span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行预编译指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>这样我们就将预编译的结果存在了test.i文件中，打开这个文件，发现内容非常多，其实看一下，就知道，前面都是头文件stdio.h的展开，因为stdio.h中又包含了其他头文件，这些头文件都会展开，所以test.i这个文件会比较大，我们提取一部分看下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">extern FILE *stdin;</span><br><span class="line">extern FILE *stdout;</span><br><span class="line">extern FILE *stderr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"></span><br><span class="line">extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int renameat (int __oldfd, const char *__old, int __newfd,</span><br><span class="line">       const char *__new) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"># 173 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *tmpfile (void) ;</span><br><span class="line"># 187 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"># 204 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern char *tempnam (const char *__dir, const char *__pfx)</span><br><span class="line">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int fclose (FILE *__stream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int fflush (FILE *__stream);</span><br><span class="line"># 227 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern int fflush_unlocked (FILE *__stream);</span><br><span class="line"># 246 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fopen (const char *__restrict __filename,</span><br><span class="line">      const char *__restrict __modes) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern FILE *freopen (const char *__restrict __filename,</span><br><span class="line">        const char *__restrict __modes,</span><br><span class="line">        FILE *__restrict __stream) ;</span><br><span class="line"># 279 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"># 292 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)</span><br><span class="line">  __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">extern int printf (const char *__restrict __format, ...);</span><br></pre></td></tr></table></figure>
<p>再看我们的main函数变成什么了，拉到test.i文件的最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line"></span><br><span class="line">    int c = a + b;</span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，定义的两个宏在代码中已经用宏的值替换了，注释也删除了。<br>以上我们就了解了预编译到底做了啥。</p>
<p>到这里，我们就可以来解释一个问题，就是我们在定义一个头文件的时候，一般都要采取如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef XXXX_H</span><br><span class="line">#define XXXX_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>为什么要这么做呢，防止重复包含头文件后的重复展开，导致函数声明重复。这样操作后，即便同一个头文件包含了多次，也只会展开一次，不会出现问题。</p>
<p>在嵌入式开发中，我们经常就会利用这种展开机制，嵌入式开发中经常出现没有文件系统的情况，比如一些mcu方案里，操作系统是一些轻量级的rtos，不存在文件系统，而我们测试的时候，经常会有一些输入数据和参考输出数据，没有文件系统，这些数据怎么读进去呢。这个时候，就需要把这些数据编进代码里，最简单的办法就是定义一个全局数据，然后数组初始化为这些测试数据。<br>但是如果测试数据比较多，那么这个源文件里看起来就是大量的数据，不是很友好。这个时候就可以把数据放在一个文件里，比如data.dat，然后在源文件中通过#include包含进来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int g_input_data[] = </span><br><span class="line">&#123;</span><br><span class="line">#include &quot;data.dat&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，更换输入也方便，只需要换个文件就可以了。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>预编译相当于对源文件做了一个预处理，接下来编译的工作就是将源代码翻译成汇编代码。<br>gcc中编译的命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S</span><br></pre></td></tr></table></figure>

<p>我们将刚刚得到的test.i编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>输出了汇编文件test.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;test.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;c = %d\n&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	$1, -12(%rbp)</span><br><span class="line">	movl	$2, -8(%rbp)</span><br><span class="line">	movl	-12(%rbp), %edx</span><br><span class="line">	movl	-8(%rbp), %eax</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	movl	%eax, -4(%rbp)</span><br><span class="line">	movl	-4(%rbp), %eax</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">	leaq	.LC0(%rip), %rdi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	printf@PLT</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">	.section	.note.gnu.property,&quot;a&quot;</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 1f - 0f</span><br><span class="line">	.long	 4f - 1f</span><br><span class="line">	.long	 5</span><br><span class="line">0:</span><br><span class="line">	.string	 &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 0xc0000002</span><br><span class="line">	.long	 3f - 2f</span><br><span class="line">2:</span><br><span class="line">	.long	 0x3</span><br><span class="line">3:</span><br><span class="line">	.align 8</span><br><span class="line">4:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gcc将预编译和编译两步合并了，其实这两步都是调用了cc1这个程序（位于 /usr/lib/gcc/x86_64-linux-gnu/9/cc1）。</p>
<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编是将编译出来的汇编代码翻译成计算机能够执行的机器代码，基本上一条汇编指令就会对应一条机器指令。<br>gcc中汇编的指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c</span><br></pre></td></tr></table></figure>
<p>gcc汇编的过程也是调用了汇编器as完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<p>生成的test.o就是机器代码文件，也叫目标文件。在很多源代码的工程中，编译后，我们往往能够看到，每一个源文件都会生成一个.o的目标文件。</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>目标文件生成了，但是目标文件并不能直接运行，还需要通过链接生成可执行文件。链接是很重要的一步，也特别复杂，这部分后面还会专门展开写，静态链接和动态链接。<br>gcc中链接由连接器collect2完成。<br>为什么刚才的目标文件不能直接运行呢？<br>我们先把刚才的test.c完整的编译成一个可执行程序a.out（gcc中不指定输出程序名的话，默认为a.out）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了可执行程序，这个a.out是可以直接运行的。现在再来分别反汇编一下a.out和刚才的test.o，看看两者的差异，反汇编可以用objdump工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s a.out &gt; a.s</span><br><span class="line">objdump -s test.o &gt; test.s</span><br></pre></td></tr></table></figure>
<p>你会看到，两个文件差异很多，a.out里明显多出了很多内容，这些内容就是链接时生成的，而且，没有这些内容，就没法运行。</p>
<p>到这里，我们终于得到了可执行文件，终于可以运行了。可见，ide上一个简单的编译操作，它的背后其实涵盖了很多内容。</p>
<p>接下来，就是运行了，一个简单的./a.out，这背后又会发生什么呢？这就得首先从可执行文件入手了，这就是下一次的主题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E5%BC%95%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E5%BC%95%E8%A8%80/" class="post-title-link" itemprop="url">程序是如何跑起来的-引言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 13:49:17" itemprop="dateCreated datePublished" datetime="2023-03-24T13:49:17+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-13 11:20:56" itemprop="dateModified" datetime="2023-04-13T11:20:56+08:00">2023-04-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学程序的人们最先接触的就是我们所熟知的Hello World程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello World!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先会在一个ide里（比如windows下的visual studio）敲下上述代码，然后点击编译按钮编译，完成后点击运行，就会在控制台里打印出Hello World。</p>
<p>但是，我们有没有想过，这中间到底发生了什么呢？为什么一定要编译呢，可能我们都知道计算机只认识二进制文件，需要把程序翻译成二进制代码，所以需要编译。<br>那编译直接就生成了二进制文件， 还是中间会发生其他事情呢？</p>
<p>对于一些工程，我们的源代码不会只有一个源文件，那么那么多的源文件最后又是怎么生成一个可执行文件的呢？</p>
<p>大的工程，还充斥着各种静态链接和动态链接，这些又是怎么回事呢？</p>
<p>编译得到了可执行程序，比如在linux shell下，执行一个可执行程序，打印出了一串信息，这背后又发生了什么呢？</p>
<p>其实这里更加复杂，我们知道一个运行着的程序就是一个进程，我们编译出来的程序也一样，首先就需要生成一个进程来运行我们的程序。</p>
<p>问题又来了，程序是一个二进制文件，进程怎么去运行这个二进制文件呢？这里面就涉及到了目标文件问题以及程序的装载问题。</p>
<p>还有，我们学习C或者C++的时候，都知道每个程序都必须要有一个main函数，main函数是整个程序的入口点。那为什么必须要有main函数呢？其实程序中的那些全部变量在main函数之前就已经完成初始化了，C++中的全局对象在main之前就完成构造了。</p>
<p>接下来，我就准备写一个系列的文章来理清楚我们的程序到底是如何跑起来的。这是一篇简单的引言，也希望自己能够坚持写下去。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 07:55:43" itemprop="dateCreated datePublished" datetime="2023-03-24T07:55:43+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-20 20:14:16" itemprop="dateModified" datetime="2023-03-20T20:14:16+08:00">2023-03-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WarmDad</p>
  <div class="site-description" itemprop="description">WarmDad的学习与生活记录空间</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WarmDad</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
