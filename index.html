<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Arial:300,300italic,400,400italic,700,700italic|Verdana:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="WarmDad的学习与生活记录空间">
<meta property="og:type" content="website">
<meta property="og:title" content="WarmDad&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="WarmDad&#39;s Blog">
<meta property="og:description" content="WarmDad的学习与生活记录空间">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="WarmDad">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>WarmDad's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WarmDad's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/21/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">程序是如何跑起来的-静态链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-21 14:42:46 / 修改时间：14:43:13" itemprop="dateCreated datePublished" datetime="2023-07-21T14:42:46+08:00">2023-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>编译的最后一步就是链接，链接分为静态链接和动态链接，我们先讲静态链接。<br>所谓链接，就是把各个目标文件组装合并成一个可执行文件。<br>链接主要分为两步，第一步进行目标文件的合并，并进行空间地址分配；第二步就是符号解析和重定位。我们就主要分析下这个过程。<br>从前面我们知道，一个目标文件中由多个段组成，典型的有.text段，.data段，.bss段。那么链接过程如何把它们粘在一起呢？</p>
<h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><h2 id="顺序叠加"><a href="#顺序叠加" class="headerlink" title="顺序叠加"></a>顺序叠加</h2><p>最容易想到的方法就是直接叠加的方法，就多个目标文件直接拼接，如下图所示：</p>
<p><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-18-2009.png"></p>
<p>但是这样有一个很大的缺点就是最后的文件被分割成了很多个段，显得非常零散。而且，也非常浪费空间，因为在装载的时候，每一个段都会对应一个空间地址和对齐要求，一般情况下，会要求4k对齐（页对齐），这样，一个段不管多大，都会占用整数页，会产生大量内存碎片，浪费空间。</p>
<h2 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h2><p>另一种方法就是将各个目标文件的相似段合并成一个段，如下图所示<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-24-2009.png"></p>
<p>目前的连接器都是采用的这种合并方式。链接器首先扫描所有的输入目标文件，获取它们各个段的信息，并收集所有的符号统一放到一个全局符号表，然后进行符号解析和重定位等操作。</p>
<p>来看个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>; </span><br><span class="line">    <span class="type">int</span> c = add(a, g_b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="type">int</span> g_b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，将a.o和b.o链接起来<br>aarch64-none-linux-gnu-ld a.o b.o -e main -o ab<br>然后我们看看链接前后的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -h a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000038  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000078  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000078  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000005e  0000000000000000  0000000000000000  00000078  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d6  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000038  0000000000000000  0000000000000000  000000d8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aarch64-none-linux-gnu-objdump -h b.o</span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000020  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  00000060  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000064  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000005e  0000000000000000  0000000000000000  00000064  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000c2  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000030  0000000000000000  0000000000000000  000000c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aarch64-none-linux-gnu-objdump -h ab</span><br><span class="line"></span><br><span class="line">ab:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000058  0000000000400120  0000000000400120  00000120  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .eh_frame     00000050  0000000000400178  0000000000400178  00000178  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .data         00000004  0000000000410fe8  0000000000410fe8  00000fe8  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .comment      0000005d  0000000000000000  0000000000000000  00000fec  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h2><p>链接的一个重要工作就是给可执行文件分配地址空间，程序运行在内存中，所以就需要分配地址，这里一般都是指虚拟地址。<br>上面查看elf文件信息时，可以看到有个VMA和LMA，这里的VMA就是分配的虚拟地址，LMA是加载地址，一般情况下这两个地址是一样，但是在一些嵌入式系统中，程序要放在ROM中，LMA和VMA是不一样的，程序会先加载到ROM中，然后从ROM搬到内存执行。<br>这里我们关注VMA，可以看到链接之前VMA都是0，此时还没有分配地址，链接之后各个段都分配了响应的虚拟地址，.text段被分配到了地址0x400120，大小为0x58字节。<br>为什么链接器给可执行文件分配的地址会这么大呢，为什么不是从0开始呢？这里涉及一些虚拟地址空间分配的规则，在linux下，64位系统，elf可执行文件默认从地址0x400000开始分配。这块后面还会细讲。</p>
<p>完成地址分配后，各个符号的地址也就确定了，各个段内的符号相对各个段的偏移是固定的，那么经过缝合后，段的首地址确定了，那么符号的地址也就确定了。</p>
<h1 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h1><h2 id="重定位-1"><a href="#重定位-1" class="headerlink" title="重定位"></a>重定位</h2><p>完成空间分配后，就进入到静态链接的重要一环，符号解析和重定位。<br>为什么需要重定位呢？我们首先来看下a.o的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">   4:	910003fd 	mov	x29, sp</span><br><span class="line">   8:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">   c:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  10:	90000000 	adrp	x0, 0 &lt;g_b&gt;</span><br><span class="line">  14:	91000000 	add	x0, x0, #0x0</span><br><span class="line">  18:	b9400000 	ldr	w0, [x0]</span><br><span class="line">  1c:	2a0003e1 	mov	w1, w0</span><br><span class="line">  20:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  24:	94000000 	bl	0 &lt;add&gt;</span><br><span class="line">  28:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  2c:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  30:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  34:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看看ab的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d ab</span><br><span class="line"></span><br><span class="line">ab:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000400120 &lt;main&gt;:</span><br><span class="line">  400120:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">  400124:	910003fd 	mov	x29, sp</span><br><span class="line">  400128:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">  40012c:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  400130:	90000080 	adrp	x0, 410000 &lt;add+0xfea8&gt;</span><br><span class="line">  400134:	913fa000 	add	x0, x0, #0xfe8</span><br><span class="line">  400138:	b9400000 	ldr	w0, [x0]</span><br><span class="line">  40013c:	2a0003e1 	mov	w1, w0</span><br><span class="line">  400140:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  400144:	94000005 	bl	400158 &lt;add&gt;</span><br><span class="line">  400148:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  40014c:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  400150:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  400154:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">0000000000400158 &lt;add&gt;:</span><br><span class="line">  400158:	d10043ff 	sub	sp, sp, #0x10</span><br><span class="line">  40015c:	b9000fe0 	str	w0, [sp, #12]</span><br><span class="line">  400160:	b9000be1 	str	w1, [sp, #8]</span><br><span class="line">  400164:	b9400fe1 	ldr	w1, [sp, #12]</span><br><span class="line">  400168:	b9400be0 	ldr	w0, [sp, #8]</span><br><span class="line">  40016c:	0b000020 	add	w0, w1, w0</span><br><span class="line">  400170:	910043ff 	add	sp, sp, #0x10</span><br><span class="line">  400174:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比较两个main的汇编，发现有几处不同，a.o中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10:	90000000 	adrp	x0, 0 &lt;g_b&gt;</span><br><span class="line">14:	91000000 	add	x0, x0, #0x0</span><br></pre></td></tr></table></figure>
<p>和ab中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400130:	90000080 	adrp	x0, 410000 &lt;add+0xfea8&gt;</span><br><span class="line">400134:	913fa000 	add	x0, x0, #0xfe8</span><br></pre></td></tr></table></figure>
<p>还有就是a.o中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24:	94000000 	bl	0 &lt;add&gt;</span><br></pre></td></tr></table></figure>
<p>和ab中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400144:	94000005 	bl	400158 &lt;add&gt;</span><br></pre></td></tr></table></figure>

<p>adrp这条指令的作用获得变量当前页的基址，然后利用一条add指令加上变量在页内的偏移获得变量的地址。a.c在编译的时候显然是不知道外部变量g_b的地址的，所以，它就默认讲其地址设置为0。同样，add的地址也不知道，所以bl指令后面的地址也默认为0。</p>
<p>编译器不知道外部变量的地址，所以就先用0替代，然后链接器负责将其修正到正确的地址。</p>
<p>那么链接器是如何做的呢，它怎么知道哪些指令需要修正呢？其实每个elf文件都有一个重定位表，用以专门保存跟重定位相关的信息。elf文件中，每个重定位表基本都对应了一个重定位段，一个elf文件中可能存在多个重定位段。比如代码段“.text”如果有要被重定位的地方，就会有一个叫”.rel.text“的重定位段，相应的如果”.data”段中有需要重定位的地方，就会有一个“.rel.data”的重定位段。</p>
<p>我们来看下a.o的重定位表是怎样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000010 R_AARCH64_ADR_PREL_PG_HI21  g_b</span><br><span class="line">0000000000000014 R_AARCH64_ADD_ABS_LO12_NC  g_b</span><br><span class="line">0000000000000024 R_AARCH64_CALL26  add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">000000000000001c R_AARCH64_PREL32  .text</span><br></pre></td></tr></table></figure>

<p>这里展示了a.o里所有需要重定位的地方。每个要被重定位的地方叫一个重定位入口，每个入口前面的offset指的就是需要重定位的地方在段中的位置，RELOCATION RECORDS FOR [.text]指的就是代码段的重定位表。<br>重定位表在elf中也对应了一个数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_rel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr r_offset;  <span class="comment">/* Location at which to apply the action */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword r_info; <span class="comment">/* index and type of relocation */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure>
<p>r_offset 就是重定位入口的偏移，r_info是指重定位的类型，下面指令修正部分会涉及。</p>
<p>重定位的过程其实也是一个符号解析的过程，每个elf文件都有一个自己的符号表，查看a.o的符号表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -s a.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    7 $d</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">    10: 0000000000000000    56 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND g_b</span><br><span class="line">    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND add</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到g_b和add是属于UND符号，也就是undefined，说明当前目标文件中没有它们的重定位项，链接器在链接过程中，会扫描所有的输入目标文件，如果这些未定义的符号没有在全局符号表中找到，那么就会报符号未定义错误。这也是我们开发过程中编译最常见的一种错误，一般都是没有链接某个库导致。</p>
<h2 id="指令修正"><a href="#指令修正" class="headerlink" title="指令修正"></a>指令修正</h2><p>找到了需要重定位的指令之后，就需要将默认的符号地址修正成正确的目标地址。对于指令的修正方式不同的处理器会有不同的方式。比如arm64 体系结构的一些重定位类型：</p>
<ol>
<li>R_AARCH64_ABS64：绝对64位地址重定位类型。</li>
<li>R_AARCH64_ABS32：绝对32位地址重定位类型。</li>
<li>R_AARCH64_ABS16：绝对16位地址重定位类型。</li>
<li>R_AARCH64_PREL64：相对64位地址重定位类型。</li>
<li>R_AARCH64_PREL32：相对32位地址重定位类型。</li>
<li>R_AARCH64_PREL16：相对16位地址重定位类型。</li>
<li>R_AARCH64_ADR_PREL_PG_HI21：将相对地址的高21位转换为页对齐的高位。</li>
<li>R_AARCH64_ADR_PREL_PG_HI21_NC：非连续版本的R_AARCH64_ADR_PREL_PG_HI21。</li>
<li>R_AARCH64_ADD_ABS_LO12_NC：将相对地址的低12位转换为绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST8_ABS_LO12_NC：将相对地址的低12位转换为8位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST16_ABS_LO12_NC：将相对地址的低12位转换为16位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST32_ABS_LO12_NC：将相对地址的低12位转换为32位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_LDST64_ABS_LO12_NC：将相对地址的低12位转换为64位绝对地址的低12位（非连续版本）。</li>
<li>R_AARCH64_CALL26：将相对于当前指令位置的26位相对地址转换为绝对地址</li>
</ol>
<p>基本操作如下：</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>操作</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>R_AARCH64_ADR_PREL_PG_HI21</td>
<td>Page(S+A)-Page(P)</td>
<td>X[31:12]</td>
</tr>
<tr>
<td>R_AARCH64_ADD_ABS_LO12_NC</td>
<td>S+A</td>
<td>X[11:0]</td>
</tr>
<tr>
<td>R_AARCH64_CALL26</td>
<td>S+A-P</td>
<td>X[27:2]</td>
</tr>
</tbody></table>
<p>其中，S表示要重定位的符号的运行时地址，A是重新安置的加数，P是重定位站点的地址(派生自r_offset)。<code>Page(expr)</code>是表达式expr的页面地址。</p>
<p>根据这个计算出来，第一条重定位的指令修正后地址就是0x410000。bl指令对应的R_AARCH64_CALL26，计算出来后，偏移是5。（（目标地址 - 指令地址）/ 4 = 偏移）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%9A%84%E8%87%AA%E5%BC%BA%E8%BF%90%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%9A%84%E8%87%AA%E5%BC%BA%E8%BF%90%E5%8A%A8/" class="post-title-link" itemprop="url">中国近代史的自强运动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-13 11:22:04 / 修改时间：11:22:31" itemprop="dateCreated datePublished" datetime="2023-04-13T11:22:04+08:00">2023-04-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>说起中国近代史，大家都知道那是一段中国的屈辱史，各种不平等条约，各种割地赔款，简直不忍直视。大家看了这段历史，不一而同的都会喷清王朝的腐败和黑暗，然而在这段屈辱的历史里，我们也涌现出了一些自强运动，虽然方式不同，但都在努力让这个国家变强。本文主要就是聚焦于在这段历史大背景下兴起的一系列自强运动。</p>
<p>说到中国近代史，就离不开鸦片战争，那是近代史的开端，也是屈辱的开端，说到鸦片战争，就离不开林则徐。<br>大家都知道林则徐主导了广东虎门销烟，是禁烟英雄，但其实林则徐不仅仅只是一位禁烟英雄，在当时，林则徐也算是少数几位能够放眼看世界的人物之一。<br>林则徐几乎每天都会让翻译给他翻译各种外文资料，通过这些资料，他对英国贸易有了一些了解，也知道了英国商人的大体背景。然而，林则徐获取的资料也只能是一些公开的资料，再加上当时的大背景下，大清朝缺乏一个深谙当今外交事务的官员，同样也包括林则徐在内，就很难从这些资料中判断出有什么有价值的线索。<br>同时，林则徐所接受的也是最为传统的中国教育，很难从更高的角度来看待世界性问题，所以也有很多人批评林则徐，认为他作为一名有思想的政治家，应当有更高的眼光，应当有负责任的态度，善于将自发的斗争纳入正确的轨道。但其实在当时的大背景下，要做到这样，非常难。</p>
<p>鸦片战争结束了，失败不是最重要的，最重要的应该是反思失败，从失败中汲取教训，很可惜，失败引出的只是”顺夷“而不是”制夷“。鸦片战争中负有重大责任的顶级人物，没有一个做出该有的反省。</p>
<p>如此对待，第二次鸦片战争的失败也就是板上钉钉的是事了。<br>英法联军攻入北京城，火烧圆明园，最后通过谈判，签订不平等的《北京条约》解决。<br>第二次鸦片战争结束后，主导处理战后事宜的恭亲王和文祥从他们的经验里得到了一些教训：首先，他们认识到了西方的武器比我们先进很多，练兵的方法也在我们之上，因为当时大清有名的大将僧格林沁和胜保在英法联军面前也是惨败；其次，他们发现西洋人不但愿意卖武器给我们，还愿意将它们的制造方法以及练兵方法都教给我们；最后，通过他们与西洋人的打交道过程中，发现西洋人并非不守信义之徒。<br>鉴于这些经验，恭亲王和文祥觉得中国必须自强，而且也有自强的机会。于是他们就制定了大致的方略：第一，就是以夷制夷，用西洋人的武器和方法来对付西洋人。于是他们开始购买西洋武器，请外交教官训练士兵。第二，他们认识到自强不是一个短期的过程，所以在自强达到预期目标之前，中国应该谨守条约以避免再次战争，可以说，这是一个隐忍自强的过程。<br>可以说，恭亲王和文祥能够认识到这些是非常不简单的，不仅有认识，他们还敢于付诸实践，敢于大胆前进，给中国寻找新的出路，拉开了近代中国自强的序幕，也就是近代中国著名的洋务运动。</p>
<p>提到洋务运动，那就离不开李鸿章，从历史课本中，我们对李鸿章的印象基本停留在他的北洋舰队在甲午海战中全军覆没，导致签订中日《马关条约》，同时后来的《辛丑条约》也是出自他手，于是他被很多人骂成了卖国贼。</p>
<p>其实，李鸿章是一位颇有远见的人。在镇压太平天国运动过程中，他也认识到了西洋武器的先进，在给曾国藩的信中，就写道：</p>
<blockquote>
<p>鸿章尝往英、法提督兵权，见其大炮之精纯，子药之细巧，器械之鲜明，队伍之雄整，实非中国所能及……深以中国军器远逊外洋为耻，日戒谕将士虑心忍辱，学得西人一二秘法，期有增益……若驻上海久而不能资取洋人长技，咎悔多矣。</p>
</blockquote>
<p>他也认识到了时下的中国必须改变，必须变革，在给恭亲王的信中，又写道：</p>
<blockquote>
<p>鸿章窃以为天下事穷则变，变则通。中国士大夫沉浸于章句小楷之积习，武夫悍卒又多粗蠢而不加细心，以致用非所学，学非所用。无事则斥外国之利器为奇技淫巧，以为不必学；有事则惊外国之利器为变怪神奇，以为不能学。不知洋人视火器为身心性命之学者已数百年。一旦豁然贯通，参阴阳而配造化，实有指挥如意，从心所欲之快……前者英、法各国，以日本为外府，肆意诛求。日本君臣发愤为雄，选宗室及大臣子弟之聪秀者，往西国制造厂师习各艺，又购制器之器，在本国制习。现在已能驾驶轮船，造放炸炮。去年英人虚声恫愒，以兵临之。然英人所恃而为攻战之利者，彼已分擅其长，用是凝然不动而英人固无如之何也。夫今之日本即明之倭寇也，距西国远而距中国近。我有以自立，则将附丽于我，窥伺西人之短长；我无以自强，则并效尤于彼，分西人之利薮。日本以海外区区小国，尚能及时改辙，知所取法。然则我中国深维穷权而通之故，夫亦可以皇然变计矣……杜挚有言曰：利不百，不变法；功不十，不易器。苏子瞻曰：言之于无事之时，足以为名，而恒苦于不信；言之于有事之时，足以见信，而已苦于无及。鸿章以为中国欲自强则莫如学习外国利器。欲学习外国利器则莫如觅制器之器，师其法而不必尽用其人。欲觅制器之器，与制器之人，则我专设一科取士，士终身悬以为富贵功名之鹄，则业可成，业可精，而才亦可集。</p>
</blockquote>
<p>从这些可以看出，李鸿章已经认识到了当时的中国只有学习外国的先进科学技术才能生存，更加难能可贵的是，他在1864年就已经看到中国和日本谁更强，就看谁变得更快，因为他看到了日本的明治维新给日本带来了巨大的改变。更进一步，他认为改革更要改教育，要改革传统的科举制度，他要士大夫们放弃文章，而要更加重视科学工程。从这些不难看出李鸿章的伟大。</p>
<p>洋务运动中，李鸿章也做了不少实事，这里就不一一列举，比如，在上海设外国语学校，在天津设机器制造局，设轮船招商局，修建铁路，创建北洋舰队，购买国外军舰，等等。</p>
<p>洋务运动的主要特点就是大部分事业都是国防事业，当然这也好理解，毕竟当时考虑的更多就是让中国能够在军事上自强起来。<br>但是，现代化的国防事业绝非那么简单，牵扯甚多，在这个过程中，洋务运动的首脑们也是在一步一步的前进，发现问题，解决问题。<br>比如，现代军事需要现代化的武器，这就需要机械制造厂，于是江南和天津机械制造厂应运而生；现代军队需要现代交通，第一次鸦片战争，由于交通落后，跨省调兵差不多要一个多月，甚至几个月才能到达前线，援兵到，战都早打完了，所以造船厂，电报局，铁路都开始建设；还有关键的人才，所以又设置了出洋留学机制；大量的现代建设，需要大量的费用，于是，又创办招商局，开始开采煤矿。<br>总之，洋务运动开始并没有一个宏大的纲领，而是首脑们一步一步慢慢走出来的。</p>
<p>当然，洋务运动并没有获得成功，可以说，甲午海战的失败，基本宣告洋务运动的失败。<br>为什么洋务运动最终还是失败了呢？最主要的还是在于变革不彻底。<br>首先，运动首脑们都是接受的旧教育，除了李鸿章，其他人连国外都没有去过，他们能够接受学习国外的先进技术，但是要引进政治制度，那是绝无可能的，他们始终坚信中国的政治制度是正确的。比如，为了修建颐和园，李鸿章不得不把建军的款子移作修颐和园之用，导致甲午海战之前的七年，海军没有增添过一只新船，如果有现代政治制度，这种事情就不会发生。<br>其次，当时的政府缺乏审计制度，贪腐丛生，就算是李鸿章，也不廉洁，更何况他底下的其他人。<br>还有就是李鸿章本人知识的缺乏，他让非专业人士领导专业人士的典型就是所用的海军总司令是个全不知海军的丁汝昌，丁氏原是淮军带马队的，这也为失败埋下了伏笔。</p>
<p>甲午海战结束了，洋务运动也失败了，但这并没有阻挡中国想自强的决心，特别是甲午海战的失败，对国内民众刺激甚大，曾经一直是中国小弟的日本，居然打败了我们，让人难以接受，要变革的呼声也越来越高。<br>观中国历史，有一个传统，就是祖宗之法不可变，先贤定下的制度，就要历代相传，不可改变，但凡要改革，阻力必然巨大。西汉和东汉中间的王莽改新失败，宋朝的王安石变法也失败了。<br>这个时候，康有为也发现了这个问题所在，他知道要改革，必须要冲突这道思想关卡，所以他就从孔子出发，写了一篇《孔子改制考》，提出孔子本身就是一个改革家，孔子作《春秋》的目的就是在于改革法制。同时，康有为又不断的上书当时的光绪帝，大谈救国之道。年轻的光绪帝，也很想有一番作为，于是决定重用康有为，开始了著名的戊戌变法，也就是百日维新。<br>百日维新的新政最重要的两件事就是：第一，以后的考试不再考八股文，而是政治经济的策论，总之就是读书人要重视真才实学；第二，调整政府机构，裁汰了一些无用的衙门，增添了一个类似经济部的农工商总局，以推动经济建设。<br>相对来说，百日维新比洋务运动更加西化，更加现代化，它已经开始触及到了政治改革。<br>但我们知道，戊戌变法很快就失败了，最主要的原因就在于当时的权力中心并不在皇帝，而是在慈禧太后，而慈禧太后正是顽固派的代表。</p>
<p>戊戌变法也失败了，说明中国需要的是一场彻底的革命。历史推出了孙中山先生，他领导的辛亥革命最终结束了清王朝的统治，真正的改变了中国。<br>孙中山从小就出国留学，一直接受的教育就是科学的教育，接受的是科学的思想方法，这些都让他对现代化的认识远在那些洋务运动领袖之上。<br>中山先生认识到只有彻底的革命，只有推翻腐朽的清王朝，才能救中国。他创建了同盟会，并说明革命应分军法、约法、宪法三时期，他说：</p>
<blockquote>
<p>由军政时期一蹴而至宪政时期，绝不予革命政府以训练人民之时期，又绝不予人民以养成自治能力之时间，于是第一流弊在旧污未由荡涤，新治未由进行；第二流弊在粉饰旧污以为新治；第三流弊在发扬旧民，压抑新治。更端言之，即第一，民治不能实现；第二，为假民治之名行专制之实；第三，则并民治之名而去之矣。此所谓事有必至，理有固然者。</p>
</blockquote>
<p>革命党们发起了很多革命活动：<br>1906年，同盟会的会员蔡绍南、刘道一联合湖南和江西交界的秘密会党在浏阳和萍乡起事，这是同盟会成立以后的第一次革命。<br>1907年，光复会首领徐锡麟杀安徽巡抚恩铭，此事牵连了他的同志秋瑾，两人终皆遇害。<br>1907年10月，熊成基带安徽新军一部分突破安庆。他虽失败了，他的行动表明长江一带的新军已受了革命思想的影响。<br>1910年2月，汪精卫和黄复生秘密地进北京，谋刺摄政王载沣失败。<br>最终在1911年10月，下级军官熊秉坤率队直入武昌，进攻总督衙门。总督瑞澂和文武官吏均弃城逃走，武昌便为革命军所据。黎元洪做起了革命军的都督。这便是著名的武昌起义，辛亥革命也就由此爆发，形成了全国性的革命运动，最终推翻了清王朝的统治。</p>
<p>辛亥革命虽然胜利了，但也仅仅在于推翻了清王朝，若要建设国家，仍有大量的障碍需要跨越。这些都已不再是本文的内容。</p>
<p>今天，我们一提起近代史，都是痛恨加痛惜，但是在痛恨的同时，我们也不应忘记那些在当时的艰难环境下仍然坚持要自强的人们，中华民族为何能够如此坚韧，为何能够屹立几千年而不断，我想也就在于此。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">程序是如何跑起来的-目标文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-13 11:16:38 / 修改时间：11:17:48" itemprop="dateCreated datePublished" datetime="2023-04-13T11:16:38+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目标文件是编译器生成的中间文件，包含了编译后的程序代码以及相关的元数据信息。目标文件在编译的过程中扮演了重要的角色，它们是编译器将源代码转换为可执行文件的重要组成部分。</p>
<h1 id="目标文件的类型"><a href="#目标文件的类型" class="headerlink" title="目标文件的类型"></a>目标文件的类型</h1><p>不同平台下目标文件格式会有所不同，比如windows下的PE，Linux下的ELF。可执行文件和目标文件的文件格式是同一种，Linux下都是ELF文件。</p>
<p>其实除了可执行文件，可重定位文件和共享目标文件都是ELF格式。</p>
<p>可重定位目标文件是指包含了程序代码和数据的二进制文件，它可以被链接器用于生成可执行文件或共享库。可重定位目标文件是编译器生成的默认文件类型。</p>
<p>可执行目标文件是指包含了完整程序代码和数据的二进制文件，它可以直接被操作系统加载并执行。</p>
<p>共享目标文件是指包含了可被多个程序共享的程序代码和数据的二进制文件，它可以被动态链接器加载到内存中，以便被多个进程共享。</p>
<p>Linux下可以用file命令来查看文件格式</p>
<h1 id="目标文件的组成"><a href="#目标文件的组成" class="headerlink" title="目标文件的组成"></a>目标文件的组成</h1><p>我们知道目标文件包含了我们程序的指令和数据，但是仅仅是这些吗？并不是的，除了指令和数据，我们还有符号表、调试信息等其他内容，同时，目标文件也会按照一定的方式来组织这些内容，按照不同的属性将这些信息组织成一个一个的段（Segment）。</p>
<p>这些段大致可以分为代码段（.text），数据段（.data)，BSS段(.bss)，符号表，调试信息等等。</p>
<p>一个C程序编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一叫.“bss”的段里。<br>为什么会有一个bss段呢，我们知道未初始化的全局变量和局部静态变量都会被初始化为0，它们本来可以放到data段，但是在data段存放数据0是没有必要的，因为程序运行的时候data段是要占据内存空间的，放在bss段，只是预留了一个位置，并没有内容，并不会占据空间，这样就能做到节省空间的目的。</p>
<p>那么为什么指令和数据要分开呢，放在一起不好吗？主要是基于以下几个原因：</p>
<ol>
<li>如果指令和数据放在一起，那么在程序被装载后，由于程序需要对数据进行读写，而指令部分是只读不写，那么这个写数据的过程就有可能因为误操作而改写了指令。分开后，数据和指令被映射到不同的区域，那么就可以针对这两个区域分别设置不同的权限。</li>
<li>第二个跟cpu的cache（缓存）有关，指令与数据分开有利于提高程序的局部性，提高cache的命中率。</li>
<li>第三个是节省空间的考虑，试想如果一个系统中运行着同一个程序的多个副本，这个时候如果指令和数据是混在一起的话，那么每个副本都需要有一份指令和数据，而如果分开的话，对于只读的指令，多个副本可以共享，这就节省了空间。</li>
</ol>
<p>对于目标文件的分析，我们来看一个用例（由于我主要基于arm平台进行开发，后面所有的分析都是基于arm平台，不过原理x86也是一样的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_blobal_val_init = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> g_blobal_val_uninit;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_uninit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_init = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    func(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只编译不链接得到目标文件SegmentTest.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -c SegmentTest.c </span><br></pre></td></tr></table></figure>

<p>对于目标文件的分析我们可以采用objdump工具，我们首先看变量所处位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -t SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，未初始化的全局变量g_blobal_val_uninit和局部静态变量static_val_uninit都在.bss段，初始化了的全局变量g_blobal_val_init和static_val_init在.data段。<br>再看下各个段的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -h SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000006c  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000ac  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000008  0000000000000000  0000000000000000  000000b4  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000008  0000000000000000  0000000000000000  000000b8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000005e  0000000000000000  0000000000000000  000000c0  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000011e  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000058  0000000000000000  0000000000000000  00000120  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看出，目标文件里，除了.data，.bss，.text，还有.rodata，.comment等其它段。同时我们能够大致看出elf文件的结构，因为这里展示了各个段的起始位置和大小，可能有的人发现了，为什么这里所有的段没有一个是从文件起始位置开始的，起始elf文件还存在在文件头，这个头是用来知识整个文件的信息的，后面会说。现在我们看到这个elf的结构如下：<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-03-27-2031.png"></p>
<p>各个段还有一些属性，其中”CONTENTS“属性表示该段是否在elf文件中存在，也就是是否有内容，我们可以看到.bss段没有这个属性，也就是说.bss段在elf文件中没有内容。</p>
<p>下面来分析下几个常见的段</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>代码段就是程序的指令，可以通过反汇编查看这些指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!</span><br><span class="line">   4:	910003fd 	mov	x29, sp</span><br><span class="line">   8:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">   c:	b9001be1 	str	w1, [sp, #24]</span><br><span class="line">  10:	b9401fe1 	ldr	w1, [sp, #28]</span><br><span class="line">  14:	b9401be0 	ldr	w0, [sp, #24]</span><br><span class="line">  18:	0b000020 	add	w0, w1, w0</span><br><span class="line">  1c:	b9002fe0 	str	w0, [sp, #44]</span><br><span class="line">  20:	b9402fe1 	ldr	w1, [sp, #44]</span><br><span class="line">  24:	90000000 	adrp	x0, 0 &lt;func&gt;</span><br><span class="line">  28:	91000000 	add	x0, x0, #0x0</span><br><span class="line">  2c:	94000000 	bl	0 &lt;printf&gt;</span><br><span class="line">  30:	b9402fe0 	ldr	w0, [sp, #44]</span><br><span class="line">  34:	a8c37bfd 	ldp	x29, x30, [sp], #48</span><br><span class="line">  38:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000000003c &lt;main&gt;:</span><br><span class="line">  3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">  40:	910003fd 	mov	x29, sp</span><br><span class="line">  44:	52800020 	mov	w0, #0x1                   	// #1</span><br><span class="line">  48:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  4c:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">  50:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  54:	b9401be1 	ldr	w1, [sp, #24]</span><br><span class="line">  58:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  5c:	94000000 	bl	0 &lt;func&gt;</span><br><span class="line">  60:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  64:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  68:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反汇编中第二列的十六进制数就是机器指令，可以看到，每一条汇编指令都对应了一条机器指令。还可以看到main函数中用bl跳转指令，跳到了func函数，func函数中同样用bl指令跳转到printf函数。</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>从上面我可以看到，数据段的大小是8个字节，刚好对应变量g_blobal_val_init和static_val_init。<br>这里顺便也提一下一个只读数据段，.rodata，这个段一般会存一些只读的变量和字符串常量。比如printf函数中的字符串常量”c=%d”，就在这个段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .data:</span><br><span class="line"> 0000 03000000 04000000                    ........        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 63203d20 25640a00                    c = %d..    </span><br></pre></td></tr></table></figure>
<p>在嵌入式开发中，一般会将.rodata段放在只读的ROM中，这样会保证这些数据不会被破坏。</p>
<h2 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h2><p>未初始化的全局变量和局部静态变量会放在.bss段，所以，上述g_blobal_val_uninit和static_val_uninit都在.bss段。</p>
<p>除了这几个常见的段，elf文件还有很多其他段，这里不再一一解释。</p>
<p>下面我们来看看如何自定义一个段，这在嵌入式开发中是一个非常常见的操作，特别是在一些裸驱的开发中。</p>
<h2 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h2><p>首先我们来看gcc提供的一个扩展机制，这个机制支持程序员将变量定义到一个特定的段上。<br>比如上面的代码加一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="type">int</span> sec_tst = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>编译后查看段信息，可以看到sec_tst在自定义的FOO段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  FOO	0000000000000000 FOO</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     O FOO	0000000000000004 sec_tst</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>裸驱开发中我们更多的会利用链接脚本（lds文件），在lds文件中定义好自己的段，然后在代码中定义变量时指定放在相应的段，特别是将某个段放到一块固定的地址上，这样一些信息放在这个段，后面调试查看相应变量的值直接到这个段的地址来看就行。<br>比如我们一个项目中就在dsp的ld文件中专门定义的一个段，专门用于存放软件版本信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN shram</span><br><span class="line">0xff000000: sysram : shram : 0x0100000 : executable, writable ;</span><br><span class="line"> shram0 : C : 0xff000000 - 0xff03ffff :  .loadM.data .loadM.bss;</span><br><span class="line"> shram1 : C : 0xff040000 - 0xff09fdff :  .shram.rodata .shram.literal .shram.text .shram.data .shram.bss;</span><br><span class="line"> shram2 : C : 0xff0ffc00 - 0xff0fffff :  .version.data .version.bss;</span><br><span class="line">END shram</span><br></pre></td></tr></table></figure>

<h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p>可执行文件是ELF文件格式，那么在程序运行的装载阶段，就必须解析这个文件，这样，就得知道ELF文件的组织结构。ELF文件分成4个部分：ELF首部、程序首部表<br>（program header table）、节（section）和节首部表（section header<br>table）。大致如下图所示<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h2 id="ELF首部"><a href="#ELF首部" class="headerlink" title="ELF首部"></a>ELF首部</h2><p>上面已经提到，ELF文件的开头是一个elf文件头信息。这个可以通过readelf工具查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -h SegmentTest.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1248 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br></pre></td></tr></table></figure>

<p>对应的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_type;  <span class="comment">/*elf 文件类型，1表示可重定位文件（目标文件），2表示可  </span></span><br><span class="line"><span class="comment">执行文件，3表示动态库，4表示核心转储文件*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_machine; <span class="comment">/* 机器类别，例如EM_ARM(40)表示ARM 32位，  </span></span><br><span class="line"><span class="comment">EM_AARCH64(183)表示ARM 64位*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_version;  <span class="comment">/*版本，用来区分不同的ELF变体*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr e_entry;   <span class="comment">/* 程序入口的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_phoff;    <span class="comment">/* 程序首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_shoff;    <span class="comment">/* 节首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_flags;   <span class="comment">/* 处理器特定的标志 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_ehsize;  <span class="comment">/* ELF首部的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phentsize; <span class="comment">/* 程序首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phnum;     <span class="comment">/* 程序首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shentsize;  <span class="comment">/* 节首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shnum;     <span class="comment">/* 节首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shstrndx;   <span class="comment">/* 节名称字符串表在节首部表中的索引 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<p>Linux内核加载ELF文件主要通过一个函数（具体装载过程后续会专门写）load_elf_binary（位于fs/binfmt_elf.c)进行。<br>第一步就是检查文件的头部信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elf_ex-&gt;e_type != ET_EXEC &amp;&amp; elf_ex-&gt;e_type != ET_DYN)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!elf_check_arch(elf_ex))</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>段表（segment table）就是程序首部表，描述各个段信息。段（segment）是从运行的角度来描述的，节（section）是从链接的角度描述的，一个段可以包含多个节，通常我们会把节称为段，比如代码段（text section），具体后续会有讲。<br>段表描述各个段的信息，编译器、连接器和装载器都是靠段表来定位和访问各个段的信息的。<br>段表也有一个对应的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_type;     <span class="comment">/*段的类型，常见的段类型如下。  </span></span><br><span class="line"><span class="comment">						可加载段（PT_LOAD，类型值为1）  </span></span><br><span class="line"><span class="comment">						解释器段（PT_INTERP，类型值为3）*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_flags;    <span class="comment">/* 段的标志，常用的3个权限标志是读、写和执行 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off p_offset;   <span class="comment">/* 段在文件中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_vaddr;   <span class="comment">/* 段的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_paddr;   <span class="comment">/* 段的物理地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_filesz;   <span class="comment">/* 段在文件中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_memsz;    <span class="comment">/* 段在内存中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_align;    <span class="comment">/* 段的对齐值 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<p>同样，节（section）也有对应的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_name;   <span class="comment">/* 节名称在节名称字符串表中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_type;   <span class="comment">/* 节的类型 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_flags;   <span class="comment">/* 节的属性 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr sh_addr;   <span class="comment">/* 节在执行时的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off sh_offset;    <span class="comment">/* 节的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_size;    <span class="comment">/* 节的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_link;   <span class="comment">/* 引用另一个节首部表表项，指定该表项的索引 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_info;   <span class="comment">/* 附加的节信息 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_addralign; <span class="comment">/* 节的对齐值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_entsize; <span class="comment">/* 如果节包含一个表项长度固定的表，例如符号表，那么这  </span></span><br><span class="line"><span class="comment">                            个成员存放表项的长度 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<p>我们可以分别用readelf -l和readelf -S查看elf文件的段表和节首部表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -S SegmentTest.o</span><br><span class="line">There are 13 section headers, starting at offset 0x4e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000006c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000003e8</span><br><span class="line">       0000000000000060  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000ac</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000b4</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000008  0000000000000000   A       0     0     8</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000c0</span><br><span class="line">       000000000000005e  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  0000011e</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000120</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000448</span><br><span class="line">       0000000000000030  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000178</span><br><span class="line">       00000000000001f8  0000000000000018          11    16     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000370</span><br><span class="line">       0000000000000072  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000478</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的Segment.o是编译后产生的.o文件，还没有链接，所以用了readelf -S来查看各个段（这里说的段其实是节，但是我们一般说段，上面已讲）的信息。总共有13个段，就是13个elf64_shdr结构的数组。<br>结合上面的头部信息，我们就大致知道了Segment.o的分布情况了<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>我们在编译代码的过程中，经常会遇到undefined symol的情况，一般都是某个函数没有定义，或者某个全局变量没有声明。<br>这里就提到了符号的概念，对于代码源文件，函数和变量都统称为符号，而链接的过程是把所有的目标文件粘合在一起，一个文件可能引用了其他文件中的符号，所以，目标文件就需要对符号做一个管理。每一个目标文件都会有一个对应的符号表，这个表里记录了目标文件中所用到的所有符号。<br>符号有多种，但我们关注主要就是定义在本文件的全局符号和在本文件引用的定义在其他文件中的全局符号。<br>可以使用nm命令查看目标文件的符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-nm SegmentTest.o</span><br><span class="line">0000000000000000 T func</span><br><span class="line">0000000000000000 D g_blobal_val_init</span><br><span class="line">0000000000000000 B g_blobal_val_uninit</span><br><span class="line">000000000000003c T main</span><br><span class="line">                 U printf</span><br><span class="line">0000000000000004 d static_val_init.1</span><br><span class="line">0000000000000004 b static_val_uninit.0</span><br></pre></td></tr></table></figure>

<h2 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h2><p>符号表在elf文件中一般是一个段，.symtab，符号表也对应一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word st_name;   <span class="comment">/* 符号名 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;  <span class="comment">/* 符号类型和绑定信息 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other; <span class="comment">/* 目前没用，为0 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half st_shndx;    <span class="comment">/* 符号所在的段 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr st_value;    <span class="comment">/* 符号对应的值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword st_size;    <span class="comment">/* 符号大小 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>我们来看一下这个符号类型和绑定信息，低4为表示符号类型，高4位为绑定信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_LOCAL  0  <span class="comment">//局部符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_GLOBAL 1  <span class="comment">//全局符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_WEAK   2  <span class="comment">//弱符号</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//符号类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_NOTYPE  0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_OBJECT  1   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FUNC    2   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_SECTION 3   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FILE    4   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_COMMON  5   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_TLS     6</span></span><br></pre></td></tr></table></figure>

<p>我们再用readelf -s来看目标文件的符号信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -s SegmentTest.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 21 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS SegmentTest.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    3 $d</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">    10: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_val_init.1</span><br><span class="line">    11: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_val_uninit.0</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">    13: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    8 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    15: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">    16: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_blobal_val_init</span><br><span class="line">    17: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 g_blobal_val_uninit</span><br><span class="line">    18: 0000000000000000    60 FUNC    GLOBAL DEFAULT    1 func</span><br><span class="line">    19: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br><span class="line">    20: 000000000000003c    48 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个更加清晰，基本与上面的数据结构能够对应起来。</p>
<h2 id="弱符号和强符号"><a href="#弱符号和强符号" class="headerlink" title="弱符号和强符号"></a>弱符号和强符号</h2><p>首先我们先看一下弱符号和强符号的一些链接规则：</p>
<ol>
<li>不允许强符号被多次定义，如果有，则链接器报符号重复定义错误，这种情况我们经常遇到；</li>
<li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号；</li>
<li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比如目标文件A定义全局变量global为int型，占4个字节：目标文件B定义global为double型，占8个字节，那么目标文件A和B链接后，符号global占8个字节。</li>
</ol>
<p>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号，我们也可以通过gcc的__attribute__((weak))来定义一个强符号为弱符号。<br>比如这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) weak1 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，weak和weak2是弱符号，strong和main都是强符号。<br>同样，GCC可以使用__attribute__((weakref))这个扩展来声明一个外部函数的引用为弱引用。<br>连接器在处理弱符号时，如果符号未定义，链接器并不会报错，一般会默认其为0，所以如果调用一个未定义的弱符号函数，只有在运行时才会奔溃，这个需要特别小心。</p>
<p>那么为什么要有这个弱符号呢？这个对库是很有用的，比如我们在库中的某个函数需要放开给用户自定义，那么就可以在库里将这个函数定义成弱引用，如果用户重新定义了这个函数为强符号，那么在链接的时候就会选择用户的函数，如果用户没有重新定义，那就会采用库里默认的函数。</p>
<h2 id="常见的extern-“C”"><a href="#常见的extern-“C”" class="headerlink" title="常见的extern “C”"></a>常见的extern “C”</h2><p>最后讲一下我们开发中常见的extern “C”，这个是干啥用的呢，主要是一些代码是用C++开发的，但是要C兼容，比如一个库用C++开发，而用户用的是C开发，那么这个库的头文件就会用extern “C”修饰。</p>
<p>为什么需要这个呢？还是符号的原因。<br>C++编译生成的目标文件跟C生成的目标文件中符号规则不一样，比如上面的Segment.c用g++编译的话，func函数的符号就是_Z4funcii，而C生成的符号就是func，加extern “C”的目的就是告诉编译器不要生成C++形式的符号，而是C形式的符号，这样，用户在用C编译代码的时候，才能够找到符号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">程序是如何跑起来的-编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-24 13:53:19 / 修改时间：17:24:00" itemprop="dateCreated datePublished" datetime="2023-03-24T13:53:19+08:00">2023-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上次简单写了一个引言，接下来我们就从编译开始。要说明下，本文不会深入讲解编译原理，那是一个非常大的课题，同时暂时不了解这些原理也不影响理解后面的内容。</p>
<p>为什么很多老手总是建议新手少用ide，其实也是有一定原因的，因为ide掩盖了很多事情。</p>
<p>就从ide上一个编译来说，这中间其实包含了几个步骤。</p>
<p>我们知道编译的作用就是将我们的源代码生成一个可执行文件。其实这中间包含了四个步骤：预编译、编译、汇编和链接。我们一步一步的来看。</p>
<h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><p>这是编译的第一步，这一步主要处理以#开头的预编译指令，比如#include，#define等，大概会做如下事情：</p>
<ol>
<li>将所有#include的头文件展开到当前文件；</li>
<li>展开所有的宏定义，也就是代码中#define的那些宏都会用值替代；</li>
<li>处理所有的#if …#else…#elif…#endif这些条件编译指令；</li>
<li>删除所有的注释；</li>
<li>添加行号和文件号标识，便于调试。</li>
</ol>
<p>gcc中预编译的指令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E</span><br></pre></td></tr></table></figure>

<p>我们用个例子来看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define A  1</span><br><span class="line">#define B  2</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = A;</span><br><span class="line">    int b = B;</span><br><span class="line"></span><br><span class="line">    int c = a + b;  /* add a and b, store the result to c */</span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行预编译指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>这样我们就将预编译的结果存在了test.i文件中，打开这个文件，发现内容非常多，其实看一下，就知道，前面都是头文件stdio.h的展开，因为stdio.h中又包含了其他头文件，这些头文件都会展开，所以test.i这个文件会比较大，我们提取一部分看下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">extern FILE *stdin;</span><br><span class="line">extern FILE *stdout;</span><br><span class="line">extern FILE *stderr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"></span><br><span class="line">extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int renameat (int __oldfd, const char *__old, int __newfd,</span><br><span class="line">       const char *__new) __attribute__ ((__nothrow__ , __leaf__));</span><br><span class="line"># 173 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *tmpfile (void) ;</span><br><span class="line"># 187 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"># 204 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern char *tempnam (const char *__dir, const char *__pfx)</span><br><span class="line">     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int fclose (FILE *__stream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int fflush (FILE *__stream);</span><br><span class="line"># 227 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern int fflush_unlocked (FILE *__stream);</span><br><span class="line"># 246 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fopen (const char *__restrict __filename,</span><br><span class="line">      const char *__restrict __modes) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern FILE *freopen (const char *__restrict __filename,</span><br><span class="line">        const char *__restrict __modes,</span><br><span class="line">        FILE *__restrict __stream) ;</span><br><span class="line"># 279 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line"># 292 &quot;/usr/include/stdio.h&quot; 3 4</span><br><span class="line">extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)</span><br><span class="line">  __attribute__ ((__nothrow__ , __leaf__)) ;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">extern int printf (const char *__restrict __format, ...);</span><br></pre></td></tr></table></figure>
<p>再看我们的main函数变成什么了，拉到test.i文件的最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line"></span><br><span class="line">    int c = a + b;</span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d\n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，定义的两个宏在代码中已经用宏的值替换了，注释也删除了。<br>以上我们就了解了预编译到底做了啥。</p>
<p>到这里，我们就可以来解释一个问题，就是我们在定义一个头文件的时候，一般都要采取如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef XXXX_H</span><br><span class="line">#define XXXX_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>为什么要这么做呢，防止重复包含头文件后的重复展开，导致函数声明重复。这样操作后，即便同一个头文件包含了多次，也只会展开一次，不会出现问题。</p>
<p>在嵌入式开发中，我们经常就会利用这种展开机制，嵌入式开发中经常出现没有文件系统的情况，比如一些mcu方案里，操作系统是一些轻量级的rtos，不存在文件系统，而我们测试的时候，经常会有一些输入数据和参考输出数据，没有文件系统，这些数据怎么读进去呢。这个时候，就需要把这些数据编进代码里，最简单的办法就是定义一个全局数据，然后数组初始化为这些测试数据。<br>但是如果测试数据比较多，那么这个源文件里看起来就是大量的数据，不是很友好。这个时候就可以把数据放在一个文件里，比如data.dat，然后在源文件中通过#include包含进来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int g_input_data[] = </span><br><span class="line">&#123;</span><br><span class="line">#include &quot;data.dat&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，更换输入也方便，只需要换个文件就可以了。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>预编译相当于对源文件做了一个预处理，接下来编译的工作就是将源代码翻译成汇编代码。<br>gcc中编译的命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S</span><br></pre></td></tr></table></figure>

<p>我们将刚刚得到的test.i编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>输出了汇编文件test.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;test.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;c = %d\n&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	$1, -12(%rbp)</span><br><span class="line">	movl	$2, -8(%rbp)</span><br><span class="line">	movl	-12(%rbp), %edx</span><br><span class="line">	movl	-8(%rbp), %eax</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	movl	%eax, -4(%rbp)</span><br><span class="line">	movl	-4(%rbp), %eax</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">	leaq	.LC0(%rip), %rdi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	printf@PLT</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">	.section	.note.gnu.property,&quot;a&quot;</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 1f - 0f</span><br><span class="line">	.long	 4f - 1f</span><br><span class="line">	.long	 5</span><br><span class="line">0:</span><br><span class="line">	.string	 &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 0xc0000002</span><br><span class="line">	.long	 3f - 2f</span><br><span class="line">2:</span><br><span class="line">	.long	 0x3</span><br><span class="line">3:</span><br><span class="line">	.align 8</span><br><span class="line">4:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gcc将预编译和编译两步合并了，其实这两步都是调用了cc1这个程序（位于 /usr/lib/gcc/x86_64-linux-gnu/9/cc1）。</p>
<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编是将编译出来的汇编代码翻译成计算机能够执行的机器代码，基本上一条汇编指令就会对应一条机器指令。<br>gcc中汇编的指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c</span><br></pre></td></tr></table></figure>
<p>gcc汇编的过程也是调用了汇编器as完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<p>生成的test.o就是机器代码文件，也叫目标文件。在很多源代码的工程中，编译后，我们往往能够看到，每一个源文件都会生成一个.o的目标文件。</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>目标文件生成了，但是目标文件并不能直接运行，还需要通过链接生成可执行文件。链接是很重要的一步，也特别复杂，这部分后面还会专门展开写，静态链接和动态链接。<br>gcc中链接由连接器collect2完成。<br>为什么刚才的目标文件不能直接运行呢？<br>我们先把刚才的test.c完整的编译成一个可执行程序a.out（gcc中不指定输出程序名的话，默认为a.out）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了可执行程序，这个a.out是可以直接运行的。现在再来分别反汇编一下a.out和刚才的test.o，看看两者的差异，反汇编可以用objdump工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s a.out &gt; a.s</span><br><span class="line">objdump -s test.o &gt; test.s</span><br></pre></td></tr></table></figure>
<p>你会看到，两个文件差异很多，a.out里明显多出了很多内容，这些内容就是链接时生成的，而且，没有这些内容，就没法运行。</p>
<p>到这里，我们终于得到了可执行文件，终于可以运行了。可见，ide上一个简单的编译操作，它的背后其实涵盖了很多内容。</p>
<p>接下来，就是运行了，一个简单的./a.out，这背后又会发生什么呢？这就得首先从可执行文件入手了，这就是下一次的主题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E5%BC%95%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E5%BC%95%E8%A8%80/" class="post-title-link" itemprop="url">程序是如何跑起来的-引言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 13:49:17" itemprop="dateCreated datePublished" datetime="2023-03-24T13:49:17+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-13 11:20:56" itemprop="dateModified" datetime="2023-04-13T11:20:56+08:00">2023-04-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学程序的人们最先接触的就是我们所熟知的Hello World程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello World!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先会在一个ide里（比如windows下的visual studio）敲下上述代码，然后点击编译按钮编译，完成后点击运行，就会在控制台里打印出Hello World。</p>
<p>但是，我们有没有想过，这中间到底发生了什么呢？为什么一定要编译呢，可能我们都知道计算机只认识二进制文件，需要把程序翻译成二进制代码，所以需要编译。<br>那编译直接就生成了二进制文件， 还是中间会发生其他事情呢？</p>
<p>对于一些工程，我们的源代码不会只有一个源文件，那么那么多的源文件最后又是怎么生成一个可执行文件的呢？</p>
<p>大的工程，还充斥着各种静态链接和动态链接，这些又是怎么回事呢？</p>
<p>编译得到了可执行程序，比如在linux shell下，执行一个可执行程序，打印出了一串信息，这背后又发生了什么呢？</p>
<p>其实这里更加复杂，我们知道一个运行着的程序就是一个进程，我们编译出来的程序也一样，首先就需要生成一个进程来运行我们的程序。</p>
<p>问题又来了，程序是一个二进制文件，进程怎么去运行这个二进制文件呢？这里面就涉及到了目标文件问题以及程序的装载问题。</p>
<p>还有，我们学习C或者C++的时候，都知道每个程序都必须要有一个main函数，main函数是整个程序的入口点。那为什么必须要有main函数呢？其实程序中的那些全部变量在main函数之前就已经完成初始化了，C++中的全局对象在main之前就完成构造了。</p>
<p>接下来，我就准备写一个系列的文章来理清楚我们的程序到底是如何跑起来的。这是一篇简单的引言，也希望自己能够坚持写下去。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-24 07:55:43" itemprop="dateCreated datePublished" datetime="2023-03-24T07:55:43+08:00">2023-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-20 20:14:16" itemprop="dateModified" datetime="2023-03-20T20:14:16+08:00">2023-03-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WarmDad</p>
  <div class="site-description" itemprop="description">WarmDad的学习与生活记录空间</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WarmDad</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
