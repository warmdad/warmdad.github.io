<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Arial:300,300italic,400,400italic,700,700italic|Verdana:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目标文件是编译器生成的中间文件，包含了编译后的程序代码以及相关的元数据信息。目标文件在编译的过程中扮演了重要的角色，它们是编译器将源代码转换为可执行文件的重要组成部分。 目标文件的类型不同平台下目标文件格式会有所不同，比如windows下的PE，Linux下的ELF。可执行文件和目标文件的文件格式是同一种，Linux下都是ELF文件。 其实除了可执行文件，可重定位文件和共享目标文件都是ELF格式。">
<meta property="og:type" content="article">
<meta property="og:title" content="程序是如何跑起来的-目标文件">
<meta property="og:url" content="http://example.com/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="WarmDad&#39;s Blog">
<meta property="og:description" content="目标文件是编译器生成的中间文件，包含了编译后的程序代码以及相关的元数据信息。目标文件在编译的过程中扮演了重要的角色，它们是编译器将源代码转换为可执行文件的重要组成部分。 目标文件的类型不同平台下目标文件格式会有所不同，比如windows下的PE，Linux下的ELF。可执行文件和目标文件的文件格式是同一种，Linux下都是ELF文件。 其实除了可执行文件，可重定位文件和共享目标文件都是ELF格式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-03-27-2031.png">
<meta property="og:image" content="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png">
<meta property="og:image" content="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png">
<meta property="article:published_time" content="2023-04-13T03:16:38.000Z">
<meta property="article:modified_time" content="2023-04-13T03:17:48.437Z">
<meta property="article:author" content="WarmDad">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-03-27-2031.png">

<link rel="canonical" href="http://example.com/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>程序是如何跑起来的-目标文件 | WarmDad's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WarmDad's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WarmDad">
      <meta itemprop="description" content="WarmDad的学习与生活记录空间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmDad's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序是如何跑起来的-目标文件
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-13 11:16:38 / 修改时间：11:17:48" itemprop="dateCreated datePublished" datetime="2023-04-13T11:16:38+08:00">2023-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>目标文件是编译器生成的中间文件，包含了编译后的程序代码以及相关的元数据信息。目标文件在编译的过程中扮演了重要的角色，它们是编译器将源代码转换为可执行文件的重要组成部分。</p>
<h1 id="目标文件的类型"><a href="#目标文件的类型" class="headerlink" title="目标文件的类型"></a>目标文件的类型</h1><p>不同平台下目标文件格式会有所不同，比如windows下的PE，Linux下的ELF。可执行文件和目标文件的文件格式是同一种，Linux下都是ELF文件。</p>
<p>其实除了可执行文件，可重定位文件和共享目标文件都是ELF格式。</p>
<p>可重定位目标文件是指包含了程序代码和数据的二进制文件，它可以被链接器用于生成可执行文件或共享库。可重定位目标文件是编译器生成的默认文件类型。</p>
<p>可执行目标文件是指包含了完整程序代码和数据的二进制文件，它可以直接被操作系统加载并执行。</p>
<p>共享目标文件是指包含了可被多个程序共享的程序代码和数据的二进制文件，它可以被动态链接器加载到内存中，以便被多个进程共享。</p>
<p>Linux下可以用file命令来查看文件格式</p>
<h1 id="目标文件的组成"><a href="#目标文件的组成" class="headerlink" title="目标文件的组成"></a>目标文件的组成</h1><p>我们知道目标文件包含了我们程序的指令和数据，但是仅仅是这些吗？并不是的，除了指令和数据，我们还有符号表、调试信息等其他内容，同时，目标文件也会按照一定的方式来组织这些内容，按照不同的属性将这些信息组织成一个一个的段（Segment）。</p>
<p>这些段大致可以分为代码段（.text），数据段（.data)，BSS段(.bss)，符号表，调试信息等等。</p>
<p>一个C程序编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一叫.“bss”的段里。<br>为什么会有一个bss段呢，我们知道未初始化的全局变量和局部静态变量都会被初始化为0，它们本来可以放到data段，但是在data段存放数据0是没有必要的，因为程序运行的时候data段是要占据内存空间的，放在bss段，只是预留了一个位置，并没有内容，并不会占据空间，这样就能做到节省空间的目的。</p>
<p>那么为什么指令和数据要分开呢，放在一起不好吗？主要是基于以下几个原因：</p>
<ol>
<li>如果指令和数据放在一起，那么在程序被装载后，由于程序需要对数据进行读写，而指令部分是只读不写，那么这个写数据的过程就有可能因为误操作而改写了指令。分开后，数据和指令被映射到不同的区域，那么就可以针对这两个区域分别设置不同的权限。</li>
<li>第二个跟cpu的cache（缓存）有关，指令与数据分开有利于提高程序的局部性，提高cache的命中率。</li>
<li>第三个是节省空间的考虑，试想如果一个系统中运行着同一个程序的多个副本，这个时候如果指令和数据是混在一起的话，那么每个副本都需要有一份指令和数据，而如果分开的话，对于只读的指令，多个副本可以共享，这就节省了空间。</li>
</ol>
<p>对于目标文件的分析，我们来看一个用例（由于我主要基于arm平台进行开发，后面所有的分析都是基于arm平台，不过原理x86也是一样的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_blobal_val_init = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> g_blobal_val_uninit;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_uninit;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_val_init = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    func(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只编译不链接得到目标文件SegmentTest.o</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -c SegmentTest.c </span><br></pre></td></tr></table></figure>

<p>对于目标文件的分析我们可以采用objdump工具，我们首先看变量所处位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -t SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，未初始化的全局变量g_blobal_val_uninit和局部静态变量static_val_uninit都在.bss段，初始化了的全局变量g_blobal_val_init和static_val_init在.data段。<br>再看下各个段的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -h SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000006c  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000ac  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000008  0000000000000000  0000000000000000  000000b4  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000008  0000000000000000  0000000000000000  000000b8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000005e  0000000000000000  0000000000000000  000000c0  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000011e  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000058  0000000000000000  0000000000000000  00000120  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看出，目标文件里，除了.data，.bss，.text，还有.rodata，.comment等其它段。同时我们能够大致看出elf文件的结构，因为这里展示了各个段的起始位置和大小，可能有的人发现了，为什么这里所有的段没有一个是从文件起始位置开始的，起始elf文件还存在在文件头，这个头是用来知识整个文件的信息的，后面会说。现在我们看到这个elf的结构如下：<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-03-27-2031.png"></p>
<p>各个段还有一些属性，其中”CONTENTS“属性表示该段是否在elf文件中存在，也就是是否有内容，我们可以看到.bss段没有这个属性，也就是说.bss段在elf文件中没有内容。</p>
<p>下面来分析下几个常见的段</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>代码段就是程序的指令，可以通过反汇编查看这些指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-objdump -d SegmentTest.o</span><br><span class="line"></span><br><span class="line">SegmentTest.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func&gt;:</span><br><span class="line">   0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!</span><br><span class="line">   4:	910003fd 	mov	x29, sp</span><br><span class="line">   8:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">   c:	b9001be1 	str	w1, [sp, #24]</span><br><span class="line">  10:	b9401fe1 	ldr	w1, [sp, #28]</span><br><span class="line">  14:	b9401be0 	ldr	w0, [sp, #24]</span><br><span class="line">  18:	0b000020 	add	w0, w1, w0</span><br><span class="line">  1c:	b9002fe0 	str	w0, [sp, #44]</span><br><span class="line">  20:	b9402fe1 	ldr	w1, [sp, #44]</span><br><span class="line">  24:	90000000 	adrp	x0, 0 &lt;func&gt;</span><br><span class="line">  28:	91000000 	add	x0, x0, #0x0</span><br><span class="line">  2c:	94000000 	bl	0 &lt;printf&gt;</span><br><span class="line">  30:	b9402fe0 	ldr	w0, [sp, #44]</span><br><span class="line">  34:	a8c37bfd 	ldp	x29, x30, [sp], #48</span><br><span class="line">  38:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000000003c &lt;main&gt;:</span><br><span class="line">  3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!</span><br><span class="line">  40:	910003fd 	mov	x29, sp</span><br><span class="line">  44:	52800020 	mov	w0, #0x1                   	// #1</span><br><span class="line">  48:	b9001fe0 	str	w0, [sp, #28]</span><br><span class="line">  4c:	52800040 	mov	w0, #0x2                   	// #2</span><br><span class="line">  50:	b9001be0 	str	w0, [sp, #24]</span><br><span class="line">  54:	b9401be1 	ldr	w1, [sp, #24]</span><br><span class="line">  58:	b9401fe0 	ldr	w0, [sp, #28]</span><br><span class="line">  5c:	94000000 	bl	0 &lt;func&gt;</span><br><span class="line">  60:	52800000 	mov	w0, #0x0                   	// #0</span><br><span class="line">  64:	a8c27bfd 	ldp	x29, x30, [sp], #32</span><br><span class="line">  68:	d65f03c0 	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反汇编中第二列的十六进制数就是机器指令，可以看到，每一条汇编指令都对应了一条机器指令。还可以看到main函数中用bl跳转指令，跳到了func函数，func函数中同样用bl指令跳转到printf函数。</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>从上面我可以看到，数据段的大小是8个字节，刚好对应变量g_blobal_val_init和static_val_init。<br>这里顺便也提一下一个只读数据段，.rodata，这个段一般会存一些只读的变量和字符串常量。比如printf函数中的字符串常量”c=%d”，就在这个段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .data:</span><br><span class="line"> 0000 03000000 04000000                    ........        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 63203d20 25640a00                    c = %d..    </span><br></pre></td></tr></table></figure>
<p>在嵌入式开发中，一般会将.rodata段放在只读的ROM中，这样会保证这些数据不会被破坏。</p>
<h2 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h2><p>未初始化的全局变量和局部静态变量会放在.bss段，所以，上述g_blobal_val_uninit和static_val_uninit都在.bss段。</p>
<p>除了这几个常见的段，elf文件还有很多其他段，这里不再一一解释。</p>
<p>下面我们来看看如何自定义一个段，这在嵌入式开发中是一个非常常见的操作，特别是在一些裸驱的开发中。</p>
<h2 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h2><p>首先我们来看gcc提供的一个扩展机制，这个机制支持程序员将变量定义到一个特定的段上。<br>比如上面的代码加一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="type">int</span> sec_tst = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>编译后查看段信息，可以看到sec_tst在自定义的FOO段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 SegmentTest.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  FOO	0000000000000000 FOO</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_val_init.1</span><br><span class="line">0000000000000004 l     O .bss	0000000000000004 static_val_uninit.0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 g_blobal_val_init</span><br><span class="line">0000000000000000 g     O .bss	0000000000000004 g_blobal_val_uninit</span><br><span class="line">0000000000000000 g     O FOO	0000000000000004 sec_tst</span><br><span class="line">0000000000000000 g     F .text	000000000000003c func</span><br><span class="line">0000000000000000         *UND*	0000000000000000 printf</span><br><span class="line">000000000000003c g     F .text	0000000000000030 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>裸驱开发中我们更多的会利用链接脚本（lds文件），在lds文件中定义好自己的段，然后在代码中定义变量时指定放在相应的段，特别是将某个段放到一块固定的地址上，这样一些信息放在这个段，后面调试查看相应变量的值直接到这个段的地址来看就行。<br>比如我们一个项目中就在dsp的ld文件中专门定义的一个段，专门用于存放软件版本信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN shram</span><br><span class="line">0xff000000: sysram : shram : 0x0100000 : executable, writable ;</span><br><span class="line"> shram0 : C : 0xff000000 - 0xff03ffff :  .loadM.data .loadM.bss;</span><br><span class="line"> shram1 : C : 0xff040000 - 0xff09fdff :  .shram.rodata .shram.literal .shram.text .shram.data .shram.bss;</span><br><span class="line"> shram2 : C : 0xff0ffc00 - 0xff0fffff :  .version.data .version.bss;</span><br><span class="line">END shram</span><br></pre></td></tr></table></figure>

<h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p>可执行文件是ELF文件格式，那么在程序运行的装载阶段，就必须解析这个文件，这样，就得知道ELF文件的组织结构。ELF文件分成4个部分：ELF首部、程序首部表<br>（program header table）、节（section）和节首部表（section header<br>table）。大致如下图所示<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h2 id="ELF首部"><a href="#ELF首部" class="headerlink" title="ELF首部"></a>ELF首部</h2><p>上面已经提到，ELF文件的开头是一个elf文件头信息。这个可以通过readelf工具查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -h SegmentTest.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1248 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br></pre></td></tr></table></figure>

<p>对应的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_type;  <span class="comment">/*elf 文件类型，1表示可重定位文件（目标文件），2表示可  </span></span><br><span class="line"><span class="comment">执行文件，3表示动态库，4表示核心转储文件*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_machine; <span class="comment">/* 机器类别，例如EM_ARM(40)表示ARM 32位，  </span></span><br><span class="line"><span class="comment">EM_AARCH64(183)表示ARM 64位*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_version;  <span class="comment">/*版本，用来区分不同的ELF变体*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr e_entry;   <span class="comment">/* 程序入口的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_phoff;    <span class="comment">/* 程序首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off e_shoff;    <span class="comment">/* 节首部表的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word e_flags;   <span class="comment">/* 处理器特定的标志 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_ehsize;  <span class="comment">/* ELF首部的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phentsize; <span class="comment">/* 程序首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_phnum;     <span class="comment">/* 程序首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shentsize;  <span class="comment">/* 节首部表中表项的长度，单位是字节 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shnum;     <span class="comment">/* 节首部表中表项的数量 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half e_shstrndx;   <span class="comment">/* 节名称字符串表在节首部表中的索引 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<p>Linux内核加载ELF文件主要通过一个函数（具体装载过程后续会专门写）load_elf_binary（位于fs/binfmt_elf.c)进行。<br>第一步就是检查文件的头部信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elf_ex-&gt;e_type != ET_EXEC &amp;&amp; elf_ex-&gt;e_type != ET_DYN)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!elf_check_arch(elf_ex))</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>段表（segment table）就是程序首部表，描述各个段信息。段（segment）是从运行的角度来描述的，节（section）是从链接的角度描述的，一个段可以包含多个节，通常我们会把节称为段，比如代码段（text section），具体后续会有讲。<br>段表描述各个段的信息，编译器、连接器和装载器都是靠段表来定位和访问各个段的信息的。<br>段表也有一个对应的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_type;     <span class="comment">/*段的类型，常见的段类型如下。  </span></span><br><span class="line"><span class="comment">						可加载段（PT_LOAD，类型值为1）  </span></span><br><span class="line"><span class="comment">						解释器段（PT_INTERP，类型值为3）*/</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word p_flags;    <span class="comment">/* 段的标志，常用的3个权限标志是读、写和执行 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off p_offset;   <span class="comment">/* 段在文件中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_vaddr;   <span class="comment">/* 段的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr p_paddr;   <span class="comment">/* 段的物理地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_filesz;   <span class="comment">/* 段在文件中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_memsz;    <span class="comment">/* 段在内存中的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword p_align;    <span class="comment">/* 段的对齐值 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<p>同样，节（section）也有对应的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_name;   <span class="comment">/* 节名称在节名称字符串表中的偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_type;   <span class="comment">/* 节的类型 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_flags;   <span class="comment">/* 节的属性 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr sh_addr;   <span class="comment">/* 节在执行时的虚拟地址 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Off sh_offset;    <span class="comment">/* 节的文件偏移 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_size;    <span class="comment">/* 节的长度 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_link;   <span class="comment">/* 引用另一个节首部表表项，指定该表项的索引 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word sh_info;   <span class="comment">/* 附加的节信息 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_addralign; <span class="comment">/* 节的对齐值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword sh_entsize; <span class="comment">/* 如果节包含一个表项长度固定的表，例如符号表，那么这  </span></span><br><span class="line"><span class="comment">                            个成员存放表项的长度 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<p>我们可以分别用readelf -l和readelf -S查看elf文件的段表和节首部表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -S SegmentTest.o</span><br><span class="line">There are 13 section headers, starting at offset 0x4e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000006c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000003e8</span><br><span class="line">       0000000000000060  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000ac</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000b4</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000008  0000000000000000   A       0     0     8</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000c0</span><br><span class="line">       000000000000005e  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  0000011e</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000120</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000448</span><br><span class="line">       0000000000000030  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000178</span><br><span class="line">       00000000000001f8  0000000000000018          11    16     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000370</span><br><span class="line">       0000000000000072  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000478</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的Segment.o是编译后产生的.o文件，还没有链接，所以用了readelf -S来查看各个段（这里说的段其实是节，但是我们一般说段，上面已讲）的信息。总共有13个段，就是13个elf64_shdr结构的数组。<br>结合上面的头部信息，我们就大致知道了Segment.o的分布情况了<br><img src="https://ycy2015.oss-cn-nanjing.aliyuncs.com/img/%E6%97%A0%E6%A0%87%E9%A2%98-2023-04-03-1952.png"></p>
<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>我们在编译代码的过程中，经常会遇到undefined symol的情况，一般都是某个函数没有定义，或者某个全局变量没有声明。<br>这里就提到了符号的概念，对于代码源文件，函数和变量都统称为符号，而链接的过程是把所有的目标文件粘合在一起，一个文件可能引用了其他文件中的符号，所以，目标文件就需要对符号做一个管理。每一个目标文件都会有一个对应的符号表，这个表里记录了目标文件中所用到的所有符号。<br>符号有多种，但我们关注主要就是定义在本文件的全局符号和在本文件引用的定义在其他文件中的全局符号。<br>可以使用nm命令查看目标文件的符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-nm SegmentTest.o</span><br><span class="line">0000000000000000 T func</span><br><span class="line">0000000000000000 D g_blobal_val_init</span><br><span class="line">0000000000000000 B g_blobal_val_uninit</span><br><span class="line">000000000000003c T main</span><br><span class="line">                 U printf</span><br><span class="line">0000000000000004 d static_val_init.1</span><br><span class="line">0000000000000004 b static_val_uninit.0</span><br></pre></td></tr></table></figure>

<h2 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h2><p>符号表在elf文件中一般是一个段，.symtab，符号表也对应一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  Elf64_Word st_name;   <span class="comment">/* 符号名 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;  <span class="comment">/* 符号类型和绑定信息 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other; <span class="comment">/* 目前没用，为0 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Half st_shndx;    <span class="comment">/* 符号所在的段 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Addr st_value;    <span class="comment">/* 符号对应的值 */</span></span><br><span class="line"></span><br><span class="line">  Elf64_Xword st_size;    <span class="comment">/* 符号大小 */</span></span><br><span class="line"></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>我们来看一下这个符号类型和绑定信息，低4为表示符号类型，高4位为绑定信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_LOCAL  0  <span class="comment">//局部符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_GLOBAL 1  <span class="comment">//全局符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_WEAK   2  <span class="comment">//弱符号</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//符号类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_NOTYPE  0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_OBJECT  1   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FUNC    2   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_SECTION 3   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_FILE    4   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_COMMON  5   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STT_TLS     6</span></span><br></pre></td></tr></table></figure>

<p>我们再用readelf -s来看目标文件的符号信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-readelf -s SegmentTest.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 21 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS SegmentTest.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    3 $d</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">    10: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_val_init.1</span><br><span class="line">    11: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_val_uninit.0</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">    13: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    8 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    15: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">    16: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_blobal_val_init</span><br><span class="line">    17: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 g_blobal_val_uninit</span><br><span class="line">    18: 0000000000000000    60 FUNC    GLOBAL DEFAULT    1 func</span><br><span class="line">    19: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br><span class="line">    20: 000000000000003c    48 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个更加清晰，基本与上面的数据结构能够对应起来。</p>
<h2 id="弱符号和强符号"><a href="#弱符号和强符号" class="headerlink" title="弱符号和强符号"></a>弱符号和强符号</h2><p>首先我们先看一下弱符号和强符号的一些链接规则：</p>
<ol>
<li>不允许强符号被多次定义，如果有，则链接器报符号重复定义错误，这种情况我们经常遇到；</li>
<li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号；</li>
<li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比如目标文件A定义全局变量global为int型，占4个字节：目标文件B定义global为double型，占8个字节，那么目标文件A和B链接后，符号global占8个字节。</li>
</ol>
<p>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号，我们也可以通过gcc的__attribute__((weak))来定义一个强符号为弱符号。<br>比如这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) weak1 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，weak和weak2是弱符号，strong和main都是强符号。<br>同样，GCC可以使用__attribute__((weakref))这个扩展来声明一个外部函数的引用为弱引用。<br>连接器在处理弱符号时，如果符号未定义，链接器并不会报错，一般会默认其为0，所以如果调用一个未定义的弱符号函数，只有在运行时才会奔溃，这个需要特别小心。</p>
<p>那么为什么要有这个弱符号呢？这个对库是很有用的，比如我们在库中的某个函数需要放开给用户自定义，那么就可以在库里将这个函数定义成弱引用，如果用户重新定义了这个函数为强符号，那么在链接的时候就会选择用户的函数，如果用户没有重新定义，那就会采用库里默认的函数。</p>
<h2 id="常见的extern-“C”"><a href="#常见的extern-“C”" class="headerlink" title="常见的extern “C”"></a>常见的extern “C”</h2><p>最后讲一下我们开发中常见的extern “C”，这个是干啥用的呢，主要是一些代码是用C++开发的，但是要C兼容，比如一个库用C++开发，而用户用的是C开发，那么这个库的头文件就会用extern “C”修饰。</p>
<p>为什么需要这个呢？还是符号的原因。<br>C++编译生成的目标文件跟C生成的目标文件中符号规则不一样，比如上面的Segment.c用g++编译的话，func函数的符号就是_Z4funcii，而C生成的符号就是func，加extern “C”的目的就是告诉编译器不要生成C++形式的符号，而是C形式的符号，这样，用户在用C编译代码的时候，才能够找到符号。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/24/%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84-%E7%BC%96%E8%AF%91/" rel="prev" title="程序是如何跑起来的-编译">
      <i class="fa fa-chevron-left"></i> 程序是如何跑起来的-编译
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/13/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%9A%84%E8%87%AA%E5%BC%BA%E8%BF%90%E5%8A%A8/" rel="next" title="中国近代史的自强运动">
      中国近代史的自强运动 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">目标文件的类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">2.</span> <span class="nav-text">目标文件的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="nav-number">2.1.</span> <span class="nav-text">代码段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="nav-number">2.2.</span> <span class="nav-text">数据段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bss%E6%AE%B5"><span class="nav-number">2.3.</span> <span class="nav-text">.bss段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AE%B5"><span class="nav-number">2.4.</span> <span class="nav-text">自定义段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">ELF文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF%E9%A6%96%E9%83%A8"><span class="nav-number">3.1.</span> <span class="nav-text">ELF首部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">段表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7"><span class="nav-number">4.</span> <span class="nav-text">符号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">符号表结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%B1%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%BC%BA%E7%AC%A6%E5%8F%B7"><span class="nav-number">4.2.</span> <span class="nav-text">弱符号和强符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84extern-%E2%80%9CC%E2%80%9D"><span class="nav-number">4.3.</span> <span class="nav-text">常见的extern “C”</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WarmDad</p>
  <div class="site-description" itemprop="description">WarmDad的学习与生活记录空间</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WarmDad</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
